From http://www.dinkum.com/vc_fixes.htmlUpdated 11 August 1998The following bug fixes correct problems in the Standard C++ Library that accompanies Microsoft Visual C++ V5.0. They should also work with V6.0, butthey have not yet been tested with that version. Each replacement header file supplied here is represented as a .txt file, so you can view it directly with a webbrowser. You can also install the replacement file directly from the browser while you are viewing it -- simply select File/Save As File and store the file withthe appropriate name in the include directory. YOU ARE STRONGLY ENCOURAGED TO SAVE THE EXISTING HEADER BEFORE OVERWRITINGIT.For example, to replace the header <deque> in a typical VC++ installation, choose the directory:c:\Program Files\DevStudio\VC\includeand save the file with the name deque. Note that some browsers insist on saving the file with the name deque.txt, in which case you will have to rename thefile after saving it from the browser.Be warned that updating a header file does not necessarily trigger a recompilation. You may have to force a rebuild to see the effect of a change.Note also that some header-file information is captured in DLLs supplied by Microsoft. If you encounter a conflict, you must either avoid using the DLL orrebuild the offending DLL. No information is available here at this time on how to deal with such DLL problems, however.DISCLAIMERThe files presented here are copyright © 1995-1998 by P.J. Plauger. All rights reserved. They are for use only in conjunction with a valid licensefor Microsoft Visual C++ V5.0. Microsoft Corporation is in no way involved with the production or release of these files. The files are offeredon an ``as is'' basis. DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIES ABOUT THESUITABILITY OF THESE FILES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIESOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD. AND P.J.PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING THESE FILES.Fix to <algorithm>The internal template algorithm _Buffered_merge (two versions) fails to initialize local variables in two places. Change the code as indicated by the comments:                if (_D2 < _D1)                        {_D1n = _D1 / 2, _D2n = 0;      // clear _D2n                        _Fn = _F;                        advance(_Fn, _D1n);                        _Ln = lower_bound(_M, _L, *_Fn);                        _Distance(_M, _Ln, _D2n); }                else                        {_D1n = 0, _D2n = _D2 / 2;      // clear _D1n                        _Ln = _M;                        advance(_Ln, _D2n);                        _Fn = upper_bound(_F, _M, *_Ln);                        _Distance(_F, _Fn, _D1n); }And for the version with predicate:                if (_D2 < _D1)                        {_D1n = _D1 / 2, _D2n = 0;      // clear _D2n                        _Fn = _F;                        advance(_Fn, _D1n);                        _Ln = lower_bound(_M, _L, *_Fn, _P);                        _Distance(_M, _Ln, _D2n); }                else                        {_D1n = 0, _D2n = _D2 / 2;      // clear _D1n                        _Ln = _M;                        advance(_Ln, _D2n);                        _Fn = upper_bound(_F, _M, *_Ln, _P);                        _Distance(_F, _Fn, _D1n); }                        Fixes to <deque>The header <deque> (updated 11 August 1998 to fix map growing problem) presented here corrects a problem with the representation of the iterator thatdesignates the end of the controlled sequence. If the sequence exactly fills the last allocated block, incrementing the iterator that designates the last element canyield a value that does not match the value returned by end(). The larger the elements stored in the container, the more likely this situation will arise.The fix is to ensure that every iterator has just one possible representation. For added security, the ends of the container are now guarded with null mappointers. It is no longer possible to step an iterator off either end of the sequence. (Such protection is not required by the C++ Standard, but it makes for nicerfailure modes in buggy code.) Note that no attempt has been made to retrofit the changes needed to make this template class exception safe in the senserequired by the final C++ Standard.// deque standard header#ifndef _DEQUE_#define _DEQUE_/* This file is for use only in conjunction with a valid license forMicrosoft Visual C++ V5.0. Microsoft Corporation is in no way involvedwith the production or release of this file. The file is offered on an``as is'' basis.DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIESABOUT THE SUITABILITY OF THIS FILES, EITHER EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD.AND P.J. PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BYLICENSEE AS A RESULT OF USING THIS FILE.For additional information, contact Dinkumware, Ltd. (+1-888-4DINKUM orsupport@dinkumware.com).Version date: 11 August 1998 */#include <iterator>#include <memory>#include <stdexcept>#include <xutility>#ifdef  _MSC_VER#pragma pack(push,8)#endif  /* _MSC_VER */_STD_BEGIN#define _DEQUEMAPSIZ    8       /* at least 5 */#define _DEQUESIZ (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))                // TEMPLATE CLASS dequetemplate<class _Ty, class _A = allocator<_Ty> >        class deque {public:        typedef deque<_Ty, _A> _Myt;        typedef _A allocator_type;        typedef _A::size_type size_type;        typedef _A::difference_type difference_type;        typedef _A::pointer _Tptr;        typedef _A::const_pointer _Ctptr;        typedef _POINTER_X(_Tptr, _A) _Mapptr;        typedef _A::reference reference;        typedef _A::const_reference const_reference;        typedef _A::value_type value_type;                // CLASS iterator        class iterator : public _Ranit<_Ty, difference_type> {        public:                friend class deque<_Ty, _A>;                iterator()                        : _First(0), _Last(0), _Next(0), _Map(0) {}                iterator(_Tptr _P, _Mapptr _M)                        : _First(*_M), _Last(*_M + _DEQUESIZ),                                _Next(_P), _Map(_M) {}                reference operator*() const                        {return (*_Next); }                _Tptr operator->() const                        {return (&**this); }                iterator& operator++()                        {if (_Next != _Last && ++_Next == _Last                                && _Map[1] != 0)                                {_First = *++_Map;                                _Last = _First + _DEQUESIZ;                                _Next = _First; }                        return (*this); }                iterator operator++(int)                        {iterator _Tmp = *this;                        ++*this;                        return (_Tmp); }                iterator& operator--()                        {if (_Next != _First)                                --_Next;                        else if (_Map[-1] != 0)                                {_First = *--_Map;                                _Last = _First + _DEQUESIZ;                                _Next = _Last - 1; }                        return (*this); }                iterator operator--(int)                        {iterator _Tmp = *this;                        --*this;                        return (_Tmp); }                iterator& operator+=(difference_type _N)                        {_Add(_N);                        return (*this); }                iterator& operator-=(difference_type _N)                        {return (*this += -_N); }                iterator operator+(difference_type _N) const                        {iterator _Tmp = *this;                        return (_Tmp += _N); }                iterator operator-(difference_type _N) const                        {iterator _Tmp = *this;                        return (_Tmp -= _N); }                difference_type operator-(const iterator& _X) const                        {return (_Map == _X._Map ? _Next - _X._Next                                : _DEQUESIZ * (_Map - _X._Map - 1)                                + (_Next - _First) + (_X._Last - _X._Next)); }                reference operator[](difference_type _N) const                        {return (*(*this + _N)); }                bool operator==(const iterator& _X) const                        {return (_Next == _X._Next); }                bool operator!=(const iterator& _X) const                        {return (!(*this == _X)); }                bool operator<(const iterator& _X) const                        {return (_Map < _X._Map                                || _Map == _X._Map && _Next < _X._Next); }                bool operator<=(const iterator& _X) const                        {return (!(_X < *this)); }                bool operator>(const iterator& _X) const                        {return (_X < *this); }                bool operator>=(const iterator& _X) const                        {return (!(*this < _X)); }        protected:                void _Add(difference_type _N)                        {difference_type _Off = _N + _Next - _First;                        difference_type _Moff = (0 <= _Off)                                ? _Off / _DEQUESIZ                                : -((_DEQUESIZ - 1 - _Off) / _DEQUESIZ);                        if (_Moff == 0)                                _Next += _N;                        else                                {_Map += _Moff;                                _First = *_Map;                                _Last = _First + _DEQUESIZ;                                _Next = _First + (_Off - _Moff * _DEQUESIZ); }}        _PROTECTED:                _Tptr _First, _Last, _Next;                _Mapptr _Map;                };                // CLASS const_iterator        class const_iterator : public iterator {        public:                const_iterator()                        {}                const_iterator(_Tptr _P, _Mapptr _M)                        : iterator(_P, _M) {}                const_iterator(const iterator& _X)                        : iterator(_X) {}                const_reference operator*() const                        {return (*_Next); }                _Ctptr operator->() const                        {return (&**this); }                const_iterator& operator++()                        {if (_Next != _Last && ++_Next == _Last                                && _Map[1] != 0)                                {_First = *++_Map;                                _Last = _First + _DEQUESIZ;                                _Next = _First; }                        return (*this); }                const_iterator operator++(int)                        {const_iterator _Tmp = *this;                        ++*this;                        return (_Tmp); }                const_iterator& operator--()                        {if (_Next != _First)                                --_Next;                        else if (_Map[-1] != 0)                                {_First = *--_Map;                                _Last = _First + _DEQUESIZ;                                _Next = _Last - 1; }                        return (*this); }                const_iterator operator--(int)                        {const_iterator _Tmp = *this;                        --*this;                        return (_Tmp); }                const_iterator& operator+=(difference_type _N)                        {_Add(_N);                        return (*this); }                const_iterator& operator-=(difference_type _N)                        {return (*this += -_N); }                const_iterator operator+(difference_type _N) const                        {iterator _Tmp = *this;                        return (_Tmp += _N); }                const_iterator operator-(difference_type _N) const                        {iterator _Tmp = *this;                        return (_Tmp -= _N); }                difference_type operator-(const const_iterator& _X) const                        {return (_Map == _X._Map ? _Next - _X._Next                                : _DEQUESIZ * (_Map - _X._Map - 1)                                + (_Next - _First) + (_X._Last - _X._Next)); }                const_reference operator[](difference_type _N) const                        {return (*(*this + _N)); }                bool operator==(const const_iterator& _X) const                        {return (_Next == _X._Next); }                bool operator!=(const const_iterator& _X) const                        {return (!(*this == _X)); }                bool operator<(const const_iterator& _X) const                        {return (_Map < _X._Map                                || _Map == _X._Map && _Next < _X._Next); }                bool operator<=(const const_iterator& _X) const                        {return (!(_X < *this)); }                bool operator>(const const_iterator& _X) const                        {return (_X < *this); }                bool operator>=(const const_iterator& _X) const                        {return (!(*this < _X)); }                };        typedef reverse_iterator<const_iterator, value_type,                const_reference, _Ctptr, difference_type>                        const_reverse_iterator;        typedef reverse_iterator<iterator, value_type,                reference, _Tptr, difference_type>                        reverse_iterator;        explicit deque(const _A& _Al = _A())                : allocator(_Al),                        _First(), _Last(), _Map(0), _Mapsize(0), _Size(0)                {}        explicit deque(size_type _N, const _Ty& _V = _Ty(),                const _A& _Al = _A())                : allocator(_Al),                        _First(), _Last(), _Map(0), _Mapsize(0), _Size(0)                {insert(begin(), _N, _V); }        deque(const _Myt& _X)                : allocator(_X.allocator),                        _First(), _Last(), _Map(0), _Mapsize(0), _Size(0)                {copy(_X.begin(), _X.end(), back_inserter(*this)); }        typedef const_iterator _It;                deque(_It _F, _It _L, const _A& _Al = _A())                : allocator(_Al),                        _First(), _Last(), _Map(0), _Mapsize(0), _Size(0)                {copy(_F, _L, back_inserter(*this)); }        ~deque()                {while (!empty())                        pop_front(); }        _Myt& operator=(const _Myt& _X)                {if (this != &_X)                        {iterator _S;                        if (_X.size() <= size())                                {_S = copy(_X.begin(), _X.end(), begin());                                erase(_S, end()); }                        else                                {const_iterator _Sx = _X.begin() + size();                                _S = copy(_X.begin(), _Sx, begin());                                copy(_Sx, _X.end(), back_inserter(*this)); }}                return (*this); }        iterator begin()                {return (_First); }        const_iterator begin() const                {return ((const_iterator)_First); }        iterator end()                {return (_Last); }        const_iterator end() const                {return ((const_iterator)_Last); }        reverse_iterator rbegin()                {return (reverse_iterator(end())); }        const_reverse_iterator rbegin() const                {return (const_reverse_iterator(end())); }        reverse_iterator rend()                {return (reverse_iterator(begin())); }        const_reverse_iterator rend() const                {return (const_reverse_iterator(begin())); }        void resize(size_type _N, _Ty _X = _Ty())                {if (size() < _N)                        insert(end(), _N - size(), _X);                else if (_N < size())                        erase(begin() + _N, end()); }        size_type size() const                {return (_Size); }        size_type max_size() const                {return (allocator.max_size()); }        bool empty() const                {return (size() == 0); }        _A get_allocator() const                {return (allocator); }        const_reference at(size_type _P) const                {if (size() <= _P)                        _Xran();                return (*(begin() + _P)); }        reference at(size_type _P)                {if (size() <= _P)                        _Xran();                return (*(begin() + _P)); }        const_reference operator[](size_type _P) const                {return (*(begin() + _P)); }        reference operator[](size_type _P)                {return (*(begin() + _P)); }        reference front()                {return (*begin()); }        const_reference front() const                {return (*begin()); }        reference back()                {return (*(end() - 1)); }        const_reference back() const                {return (*(end() - 1)); }        void push_front(const _Ty& _X)                {if (empty() || _First._Next == _First._First)                        _Buyfront();                --_First;                allocator.construct(_First._Next, _X);                ++_Size; }        void pop_front()                {if (!empty())                        {allocator.destroy(_First._Next);                        _Popfront(); }}        void push_back(const _Ty& _X)                {if (empty() || _Last._Next == _Last._Last)                        _Buyback();                ++_Last;                iterator _P = _Last - 1;                allocator.construct(_P._Next, _X);                ++_Size; }        void pop_back()                {if (!empty())                        {iterator _P = _Last - 1;                        allocator.destroy(_P._Next);                        _Popback(); }}        void assign(_It _F, _It _L)                {erase(begin(), end());                insert(begin(), _F, _L); }        void assign(size_type _N, const _Ty& _X = _Ty())                {erase(begin(), end());                insert(begin(), _N, _X); }        iterator insert(iterator _P, const _Ty& _X = _Ty())                {if (_P == begin())                        {push_front(_X);                        return (begin()); }                else if (_P == end())                        {push_back(_X);                        return (end() - 1); }                else                        {iterator _S;                        size_type _Off = _P - begin();                        _Ty _Tx = _X;                        if (_Off < size() / 2)                                {push_front(front());                                _S = begin() + _Off;                                copy(begin() + 2, _S + 1, begin() + 1); }                        else                                {push_back(back());                                _S = begin() + _Off;                                copy_backward(_S, end() - 2, end() - 1); }                        *_S = _Tx;                        return (_S); }}        void insert(iterator _P, size_type _M, const _Ty& _X)                {iterator _S;                size_type _I;                size_type _Off = _P - begin();                size_type _Rem = _Size - _Off;                if (_Off < _Rem)                        if (_Off < _M)                                {for (_I = _M - _Off; 0 < _I; --_I)                                        push_front(_X);                                for (_I = _Off; 0 < _I; --_I)                                        push_front(begin()[_M - 1]);                                _S = begin() + _M;                                fill(_S, _S + _Off, _X); }                        else                                {for (_I = _M; 0 < _I; --_I)                                        push_front(begin()[_M - 1]);                                _S = begin() + _M;                                copy(_S + _M, _S + _Off, _S);                                fill(begin() + _Off, _S + _Off, _X); }                else                        if (_Rem < _M)                                {for (_I = _M - _Rem; 0 < _I; --_I)                                        push_back(_X);                                for (_I = 0; _I < _Rem; ++_I)                                        push_back(begin()[_Off + _I]);                                _S = begin() + _Off;                                fill(_S, _S + _Rem, _X); }                        else                                {for (_I = 0; _I < _M; ++_I)                                        push_back(begin()[_Off + _Rem - _M + _I]);                                _S = begin() + _Off;                                copy_backward(_S, _S + _Rem - _M, _S + _Rem);                                fill(_S, _S + _M, _X); }}        void insert(iterator _P, _It _F, _It _L)                {size_type _M = 0;                _Distance(_F, _L, _M);                size_type _I;                size_type _Off = _P - begin();                size_type _Rem = _Size - _Off;                if (_Off < _Rem)                        if (_Off < _M)                                {_It _Qx = _F;                                advance(_Qx, _M - _Off);                                for (_It _Q = _Qx; _F != _Q; )                                        push_front(*--_Q);                                for (_I = _Off; 0 < _I; --_I)                                        push_front(begin()[_M - 1]);                                copy(_Qx, _L, begin() + _M); }                        else                                {for (_I = _M; 0 < _I; --_I)                                        push_front(begin()[_M - 1]);                                iterator _S = begin() + _M;                                copy(_S + _M, _S + _Off, _S);                                copy(_F, _L, begin() + _Off); }                else                        if (_Rem < _M)                                {_It _Qx = _F;                                advance(_Qx, _Rem);                                for (_It _Q = _Qx; _Q != _L; ++_Q)                                        push_back(*_Q);                                for (_I = 0; _I < _Rem; ++_I)                                        push_back(begin()[_Off + _I]);                                copy(_F, _Qx, begin() + _Off); }                        else                                {for (_I = 0; _I < _M; ++_I)                                        push_back(begin()[_Off + _Rem - _M + _I]);                                iterator _S = begin() + _Off;                                copy_backward(_S, _S + _Rem - _M, _S + _Rem);                                copy(_F, _L, _S); }}        iterator erase(iterator _P)                {return (erase(_P, _P + 1)); }        iterator erase(iterator _F, iterator _L)                {size_type _N = _L - _F;                size_type _M = _F - begin();                if (_M < end() - _L)                        {copy_backward(begin(), _F, _L);                        for (; 0 < _N; --_N)                                pop_front(); }                else                        {copy(_L, end(), _F);                        for (; 0 < _N; --_N)                                pop_back(); }                return (_M == 0 ? begin() : begin() + _M); }        void clear()                {erase(begin(), end()); }        void swap(_Myt& _X)                {if (allocator == _X.allocator)                        {std::swap(_First, _X._First);                        std::swap(_Last, _X._Last);                        std::swap(_Map, _X._Map);                        std::swap(_Mapsize, _X._Mapsize);                        std::swap(_Size, _X._Size); }                else                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }protected:        void _Buyback()                {_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);                if (empty())                        {_Getmap(_DEQUEMAPSIZ);                        size_type _N = _Mapsize / 2;                        _Setptr(_Map + _N - 1, 0);                        _Setptr(_Map + _N, _P);                        _Setptr(_Map + _N + 1, 0);                        _First = iterator(_P + _DEQUESIZ / 2, _Map + _N);                        _Last = _First; }                else if (_Last._Map < _Map + (_Mapsize - 2))                        {_Setptr(++_Last._Map, _P);                        _Setptr(_Last._Map + 1, 0);                        _Last = iterator(_P, _Last._Map); }                else                        {difference_type _I = _Last._Map - _First._Map + 1;                        _Mapptr _M = _Growmap(_I);                        _Setptr(_M + _I, _P);                        _Setptr(_M + _I + 1, 0);                        _First = iterator(_First._Next, _M);                        _Last = iterator(_P, _M + _I); }}        void _Buyfront()                {_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);                if (empty())                        {_Getmap(_DEQUEMAPSIZ);                        size_type _N = _Mapsize / 2;                        _Setptr(_Map + _N - 1, 0);                        _Setptr(_Map + _N, _P);                        _Setptr(_Map + _N + 1, 0);                        _First = iterator(_P + (_DEQUESIZ / 2 + 1),                                _Map + _N);                        _Last = _First; }                else if (_Map + 1 < _First._Map)                        {_Setptr(--_First._Map - 1, 0);                        _Setptr(_First._Map, _P);                        _First = iterator(_P + _DEQUESIZ, _First._Map); }                else                        {difference_type _I = _Last._Map - _First._Map + 1;                        _Mapptr _M = _Growmap(_I);                        _Setptr(--_M - 1, 0);                        _Setptr(_M, _P);                        _First = iterator(_P + _DEQUESIZ, _M);                        _Last = iterator(_Last._Next, _M + _I); }}        void _Freelast()                {_Freeptr(_First._Map - 1);                _Freeptr(_First._Map);                _Freeptr(_First._Map + 1);                _First = iterator();                _Last = _First;                _Freemap(); }        void _Popfront()                {_Mapptr _M = _First._Map;                ++_First;                --_Size;                if (empty())                        _Freelast();                else if (_M != _First._Map)                        {_Freeptr(_M);                        _Setptr(_M, 0); }}        void _Popback()                {_Mapptr _M = _Last._Map;                --_Last;                --_Size;                if (empty())                        _Freelast();                else if (_M != _Last._Map)                        {_Freeptr(_M);                        _Setptr(_M, 0); }}        void _Xran() const                {_THROW(out_of_range, "invalid deque<T> subscript"); }        void _Freemap()                {allocator.deallocate(_Map, _Mapsize); }        void _Freeptr(_Mapptr _M)                {allocator.deallocate(*_M, _DEQUESIZ); }        void _Getmap(size_type _Newsize)                {_Map = (_Mapptr)allocator._Charalloc(                        _Newsize * sizeof (_Tptr));                _Mapsize = _Newsize; }        _Mapptr _Growmap(size_type _Oldsize)                {size_type _Newsize = 2 * _Oldsize + 2;                if (_Newsize < _DEQUEMAPSIZ)                        _Newsize = _DEQUEMAPSIZ;                _Mapptr _Mx;                if (_Newsize <= _Mapsize && _Mapsize / 4 < _Newsize)                        {_Mx = _Map + _Mapsize / 4;                        if (_Mx < _First._Map - 1)                                copy(_First._Map - 1, _Last._Map + 2, _Mx);                        else                                copy_backward(_First._Map - 1, _Last._Map + 2,                                        _Mx + _Oldsize + 2); }                else                        {_Mapptr _M = (_Mapptr)allocator._Charalloc(                                _Newsize * sizeof (_Tptr));                        _Mx = _M + _Newsize / 4;                        copy(_First._Map - 1, _Last._Map + 2, _Mx);                        allocator.deallocate(_Map, _Mapsize);                        _Map = _M;                        _Mapsize = _Newsize; }                return (_Mx + 1); }        void _Setptr(_Mapptr _M, _Tptr _P)                {*_M = _P; }        _A allocator;        iterator _First, _Last;        _Mapptr _Map;        size_type _Mapsize, _Size;        };                // deque TEMPLATE OPERATORStemplate<class _Ty, class _A> inline        bool operator==(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _Ty, class _A> inline        bool operator!=(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (!(_X == _Y)); }template<class _Ty, class _A> inline        bool operator<(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _Ty, class _A> inline        bool operator<=(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (!(_Y < _X)); }template<class _Ty, class _A> inline        bool operator>(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (_Y < _X); }template<class _Ty, class _A> inline        bool operator>=(const deque<_Ty, _A>& _X,                const deque<_Ty, _A>& _Y)        {return (!(_X < _Y)); }_STD_END#ifdef  _MSC_VER#pragma pack(pop)#endif  /* _MSC_VER */#endif /* _DEQUE_ *//* * Copyright (c) 1995-1998 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* * This file is derived from software bearing the following * restrictions: * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this * software and its documentation for any purpose is hereby * granted without fee, provided that the above copyright notice * appear in all copies and that both that copyright notice and * this permission notice appear in supporting documentation. * Hewlett-Packard Company makes no representations about the * suitability of this software for any purpose. It is provided * "as is" without express or implied warranty. */Fix to <istream>The header <istream> contains a definition for member function basic_istream::getline. It has a lookahead problem -- typing a delimiter to end the inputdoesn't return control until you type yet another character. Change the code as indicated by the comment:                                else if (_C == _Di)                                        {++_Chcount;                                        rdbuf()->snextc();      // replace snextc with sbumpc                                        break; }                                        Fix to <list>(updated 7 July 1998) Both versions of the member function list::sort misplace elements if asked to sort a container with more than 32,768 elements. Tofix the first version, change the code as indicated by the comment:                                if (_I == _MAXN)                                        _A[_I].merge(_X);// SHOULD BE                            _A[_I - 1].merge(_X);Also change the corresponding line in the second version:                                if (_I == _MAXN)                                        _A[_I].merge(_X, _Pr);// SHOULD BE                            _A[_I - 1].merge(_X, _Pr);You might also consider increasing _MAXN from 15 to, say 25. That way, you would have to sort a list of more than 32 million elements, instead of 32 thousand,before the performance begins to degrade.Fix to <memory>Template class auto_ptr creates two owners for an object if you copy an auto_ptr object back to a previous owner that still stores the same object pointer. Toeliminate this problem, change the code in auto_ptr::operator= as indicated by the comment:                else if (_Y._Owns)                        _Owns = true;   // _Owns = true, _Y.release();Note that this template class has been redesigned more than once since this version of the library was frozen. No attempt is made here to track those changes.Fix to <string>The header <string> contains a definition for template function getline. It has a lookahead problem -- typing a delimiter to end the input doesn't returncontrol until you type yet another character. Change the code as indicated by the comment:                        else if (_Tr::eq(_C, _D))                                {_Chg = true;                                _I.rdbuf()->snextc();   // replace snextc with sbumpc                                break; }Fix to <xmemory>Template class _Destroy has an unfortunate interaction with a bug in the VC++ compiler. It gets confused if you ask it to destroy an object of a class thatdefines the name _Ty. (Template class complex is one such creature.) The best workaround is to replace the template parameter _Ty with a really strange name,as in:                // TEMPLATE FUNCTION _Destroytemplate<class _Xyzzy> inline        void _Destroy(_Xyzzy _FARQ *_P)        {_DESTRUCTOR(_Xyzzy, _P); }        Fixes to <xstring>The header <xstring> (original 25 May 1998) presented here corrects a problem with string assignments. Assigning a shorter sequence to an existing stringcan cause the old string to be copied in full to the newly allocated area, thus causing a storage overwrite, and an occasional storage leak as a result. In rarercircumstances, a string is partially altered by a replace member function before the copy on write occurs, thus causing changes to an apparently unrelatedstring object.The fix is a small but significant change to the private member function _Grow. Several calls to _Freeze, to force a copy on write, are also added.Please note that this implementation is still not as thread safe as it should be, because of the reference-counted implementation. A write to a ``copy'' of a stringin one thread can confuse a read of that string in another thread, because the two still secretly share the same representation. One way to ensure that thenon-const string str has a private representation is to call str.begin(). (By creating a mutable iterator into the string, you rule out sharing ofrepresentations.) Another way is to disable reference-counting altogether, making string operations thread safe. Simply change the value of _FROZEN tozero:        enum _Mref {_FROZEN = 255};  // set to zero to disable sharing        // xstring internal header (from <string>)#ifndef _XSTRING_#define _XSTRING_/* This file is for use only in conjunction with a valid license forMicrosoft Visual C++ V5.0. Microsoft Corporation is in no way involvedwith the production or release of this file. The file is offered on an``as is'' basis.DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIESABOUT THE SUITABILITY OF THIS FILE, EITHER EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD.AND P.J. PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BYLICENSEE AS A RESULT OF USING THIS FILE.For additional information, contact Dinkumware, Ltd. (+1-888-4DINKUM orsupport@dinkumware.com).Version date: 25 May 1998 */#include <xmemory>#ifdef  _MSC_VER#pragma pack(push,8)#endif  /* _MSC_VER */ #include <xutility>_STD_BEGIN_CRTIMP void __cdecl _Xlen();_CRTIMP void __cdecl _Xran();                // TEMPLATE CLASS basic_stringtemplate<class _E,        class _Tr = char_traits<_E>,        class _A = allocator<_E> >        class basic_string {public:        typedef basic_string<_E, _Tr, _A> _Myt;        typedef _A::size_type size_type;        typedef _A::difference_type difference_type;        typedef _A::pointer pointer;        typedef _A::const_pointer const_pointer;        typedef _A::reference reference;        typedef _A::const_reference const_reference;        typedef _A::value_type value_type;        typedef _A::pointer iterator;        typedef _A::const_pointer const_iterator;        typedef reverse_iterator<const_iterator, value_type,                const_reference, const_pointer, difference_type>                        const_reverse_iterator;        typedef reverse_iterator<iterator, value_type,                reference, pointer, difference_type>                        reverse_iterator;        explicit basic_string(const _A& _Al = _A())                : allocator(_Al) {_Tidy(); }        basic_string(const _Myt& _X)                : allocator(_X.allocator)                {_Tidy(), assign(_X, 0, npos); }        basic_string(const _Myt& _X, size_type _P, size_type _M,                const _A& _Al = _A())                : allocator(_Al) {_Tidy(), assign(_X, _P, _M); }        basic_string(const _E *_S, size_type _N,                const _A& _Al = _A())                : allocator(_Al) {_Tidy(), assign(_S, _N); }        basic_string(const _E *_S, const _A& _Al = _A())                : allocator(_Al) {_Tidy(), assign(_S); }        basic_string(size_type _N, _E _C, const _A& _Al = _A())                : allocator(_Al) {_Tidy(), assign(_N, _C); }        typedef const_iterator _It;        basic_string(_It _F, _It _L, const _A& _Al = _A())                : allocator(_Al) {_Tidy(); assign(_F, _L); }        ~basic_string()                {_Tidy(true); }        typedef _Tr traits_type;        typedef _A allocator_type;        enum _Mref {_FROZEN = 255};        static const size_type npos;        _Myt& operator=(const _Myt& _X)                {return (assign(_X)); }        _Myt& operator=(const _E *_S)                {return (assign(_S)); }        _Myt& operator=(_E _C)                {return (assign(1, _C)); }        _Myt& operator+=(const _Myt& _X)                {return (append(_X)); }        _Myt& operator+=(const _E *_S)                {return (append(_S)); }        _Myt& operator+=(_E _C)                {return (append(1, _C)); }        _Myt& append(const _Myt& _X)                {return (append(_X, 0, npos)); }        _Myt& append(const _Myt& _X, size_type _P, size_type _M)                {if (_X.size() < _P)                        _Xran();                size_type _N = _X.size() - _P;                if (_N < _M)                        _M = _N;                if (npos - _Len <= _M)                        _Xlen();                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);                        _Eos(_N); }                return (*this); }        _Myt& append(const _E *_S, size_type _M)                {if (npos - _Len <= _M)                        _Xlen();                size_type _N;                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::copy(_Ptr + _Len, _S, _M);                        _Eos(_N); }                return (*this); }        _Myt& append(const _E *_S)                {return (append(_S, _Tr::length(_S))); }        _Myt& append(size_type _M, _E _C)                {if (npos - _Len <= _M)                        _Xlen();                size_type _N;                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::assign(_Ptr + _Len, _M, _C);                        _Eos(_N); }                return (*this); }        _Myt& append(_It _F, _It _L)                {return (replace(end(), end(), _F, _L)); }        _Myt& assign(const _Myt& _X)                {return (assign(_X, 0, npos)); }        _Myt& assign(const _Myt& _X, size_type _P, size_type _M)                {if (_X.size() < _P)                        _Xran();                size_type _N = _X.size() - _P;                if (_M < _N)                        _N = _M;                if (this == &_X)                        erase((size_type)(_P + _N)), erase(0, _P);                else if (0 < _N && _N == _X.size()                        && _Refcnt(_X.c_str()) < _FROZEN - 1                        && allocator == _X.allocator)                        {_Tidy(true);                        _Ptr = (_E *)_X.c_str();                        _Len = _X.size();                        _Res = _X.capacity();                        ++_Refcnt(_Ptr); }                else if (_Grow(_N, true))                        {_Tr::copy(_Ptr, &_X.c_str()[_P], _N);                        _Eos(_N); }                return (*this); }        _Myt& assign(const _E *_S, size_type _N)                {if (_Grow(_N, true))                        {_Tr::copy(_Ptr, _S, _N);                        _Eos(_N); }                return (*this); }        _Myt& assign(const _E *_S)                {return (assign(_S, _Tr::length(_S))); }        _Myt& assign(size_type _N, _E _C)                {if (_N == npos)                        _Xlen();                if (_Grow(_N, true))                        {_Tr::assign(_Ptr, _N, _C);                        _Eos(_N); }                return (*this); }        _Myt& assign(_It _F, _It _L)                {return (replace(begin(), end(), _F, _L)); }        _Myt& insert(size_type _P0, const _Myt& _X)                {return (insert(_P0, _X, 0, npos)); }        _Myt& insert(size_type _P0, const _Myt& _X, size_type _P,                size_type _M)                {if (_Len < _P0 || _X.size() < _P)                        _Xran();                size_type _N = _X.size() - _P;                if (_N < _M)                        _M = _N;                if (npos - _Len <= _M)                        _Xlen();                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);                        _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);                        _Eos(_N); }                return (*this); }        _Myt& insert(size_type _P0, const _E *_S, size_type _M)                {if (_Len < _P0)                        _Xran();                if (npos - _Len <= _M)                        _Xlen();                size_type _N;                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);                        _Tr::copy(_Ptr + _P0, _S, _M);                        _Eos(_N); }                return (*this); }        _Myt& insert(size_type _P0, const _E *_S)                {return (insert(_P0, _S, _Tr::length(_S))); }        _Myt& insert(size_type _P0, size_type _M, _E _C)                {if (_Len < _P0)                        _Xran();                if (npos - _Len <= _M)                        _Xlen();                size_type _N;                if (0 < _M && _Grow(_N = _Len + _M))                        {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);                        _Tr::assign(_Ptr + _P0, _M, _C);                        _Eos(_N); }                return (*this); }        iterator insert(iterator _P, _E _C)                {size_type _P0 = _Pdif(_P, begin());                insert(_P0, 1, _C);                return (begin() + _P0); }        void insert(iterator _P, size_type _M, _E _C)                {size_type _P0 = _Pdif(_P, begin());                insert(_P0, _M, _C); }        void insert(iterator _P, _It _F, _It _L)                {replace(_P, _P, _F, _L); }        _Myt& erase(size_type _P0 = 0, size_type _M = npos)                {if (_Len < _P0)                        _Xran();                if (_Len - _P0 < _M)                        _M = _Len - _P0;                if (0 < _M)                        {_Freeze();                        _Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,                                _Len - _P0 - _M);                        size_type _N = _Len - _M;                        if (_Grow(_N))                                _Eos(_N); }                return (*this); }        iterator erase(iterator _P)                {size_t _M = _Pdif(_P, begin());                erase(_M, 1);                return (_Psum(_Ptr, _M)); }        iterator erase(iterator _F, iterator _L)                {size_t _M = _Pdif(_F, begin());                erase(_M, _Pdif(_L, _F));                return (_Psum(_Ptr, _M)); }        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)                {return (replace(_P0, _N0, _X, 0, npos)); }        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,                size_type _P, size_type _M)                {if (_Len < _P0 || _X.size() < _P)                        _Xran();                if (_Len - _P0 < _N0)                        _N0 = _Len - _P0;                size_type _N = _X.size() - _P;                if (_N < _M)                        _M = _N;                if (npos - _M <= _Len - _N0)                        _Xlen();                size_type _Nm = _Len - _N0 - _P0;                if (_M < _N0)                        {_Freeze();                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }                if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))                        {if (_N0 < _M)                                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);                        _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);                        _Eos(_N); }                return (*this); }        _Myt& replace(size_type _P0, size_type _N0, const _E *_S,                size_type _M)                {if (_Len < _P0)                        _Xran();                if (_Len - _P0 < _N0)                        _N0 = _Len - _P0;                if (npos - _M <= _Len - _N0)                        _Xlen();                size_type _Nm = _Len - _N0 - _P0;                if (_M < _N0)                        {_Freeze();                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }                size_type _N;                if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))                        {if (_N0 < _M)                                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);                        _Tr::copy(_Ptr + _P0, _S, _M);                        _Eos(_N); }                return (*this); }        _Myt& replace(size_type _P0, size_type _N0, const _E *_S)                {return (replace(_P0, _N0, _S, _Tr::length(_S))); }        _Myt& replace(size_type _P0, size_type _N0,                size_type _M, _E _C)                {if (_Len < _P0)                        _Xran();                if (_Len - _P0 < _N0)                        _N0 = _Len - _P0;                if (npos - _M <= _Len - _N0)                        _Xlen();                size_type _Nm = _Len - _N0 - _P0;                if (_M < _N0)                        {_Freeze();                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }                size_type _N;                if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))                        {if (_N0 < _M)                                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0,                                        _Nm);                        _Tr::assign(_Ptr + _P0, _M, _C);                        _Eos(_N); }                return (*this); }        _Myt& replace(iterator _F, iterator _L, const _Myt& _X)                {return (replace(                        _Pdif(_F, begin()), _Pdif(_L, _F), _X)); }        _Myt& replace(iterator _F, iterator _L, const _E *_S,                size_type _M)                {return (replace(                        _Pdif(_F, begin()), _Pdif(_L, _F), _S, _M)); }        _Myt& replace(iterator _F, iterator _L, const _E *_S)                {return (replace(                        _Pdif(_F, begin()), _Pdif(_L, _F), _S)); }        _Myt& replace(iterator _F, iterator _L, size_type _M, _E _C)                {return (replace(                        _Pdif(_F, begin()), _Pdif(_L, _F), _M, _C)); }        _Myt& replace(iterator _F1, iterator _L1,                _It _F2, _It _L2)                {size_type _P0 = _Pdif(_F1, begin());                size_type _M = 0;                _Distance(_F2, _L2, _M);                replace(_P0, _Pdif(_L1, _F1), _M, _E(0));                for (_F1 = begin() + _P0; 0 < _M; ++_F1, ++_F2, --_M)                        *_F1 = *_F2;                return (*this); }        iterator begin()                {_Freeze();                return (_Ptr); }        const_iterator begin() const                {return (_Ptr); }        iterator end()                {_Freeze();                return ((iterator)_Psum(_Ptr, _Len)); }        const_iterator end() const                {return ((const_iterator)_Psum(_Ptr, _Len)); }        reverse_iterator rbegin()                {return (reverse_iterator(end())); }        const_reverse_iterator rbegin() const                {return (const_reverse_iterator(end())); }        reverse_iterator rend()                {return (reverse_iterator(begin())); }        const_reverse_iterator rend() const                {return (const_reverse_iterator(begin())); }        reference at(size_type _P0)                {if (_Len <= _P0)                        _Xran();                _Freeze();                return (_Ptr[_P0]); }        const_reference at(size_type _P0) const                {if (_Len <= _P0)                        _Xran();                return (_Ptr[_P0]); }        reference operator[](size_type _P0)                {if (_Len < _P0 || _Ptr == 0)                        return ((reference)*_Nullstr());                _Freeze();                return (_Ptr[_P0]); }        const_reference operator[](size_type _P0) const                {if (_Ptr == 0)                        return (*_Nullstr());                else                        return (_Ptr[_P0]); }        const _E *c_str() const                {return (_Ptr == 0 ? _Nullstr() : _Ptr); }        const _E *data() const                {return (c_str()); }        size_type length() const                {return (_Len); }        size_type size() const                {return (_Len); }        size_type max_size() const                {size_type _N = allocator.max_size();                return (_N <= 2 ? 1 : _N - 2); }        void resize(size_type _N, _E _C)                {_N <= _Len ? erase(_N) : append(_N - _Len, _C); }        void resize(size_type _N)                {_N <= _Len ? erase(_N) : append(_N - _Len, _E(0)); }        size_type capacity() const                {return (_Res); }        void reserve(size_type _N = 0)                {if (_Res < _N)                        _Grow(_N); }        bool empty() const                {return (_Len == 0); }        size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const                {if (_Len < _P0)                        _Xran();                if (_Len - _P0 < _N)                        _N = _Len - _P0;                if (0 < _N)                        _Tr::copy(_S, _Ptr + _P0, _N);                return (_N); }        void swap(_Myt& _X)                {if (allocator == _X.allocator)                        {std::swap(_Ptr, _X._Ptr);                        std::swap(_Len, _X._Len);                        std::swap(_Res, _X._Res); }                else                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }        size_type find(const _Myt& _X, size_type _P = 0) const                {return (find(_X.c_str(), _P, _X.size())); }        size_type find(const _E *_S, size_type _P,                size_type _N) const                {if (_N == 0 && _P <= _Len)                        return (_P);                size_type _Nm;                if (_P < _Len && _N <= (_Nm = _Len - _P))                        {const _E *_U, *_V;                        for (_Nm -= _N - 1, _V = _Ptr + _P;                                (_U = _Tr::find(_V, _Nm, *_S)) != 0;                                _Nm -= _U - _V + 1, _V = _U + 1)                                if (_Tr::compare(_U, _S, _N) == 0)                                        return (_U - _Ptr); }                return (npos); }        size_type find(const _E *_S, size_type _P = 0) const                {return (find(_S, _P, _Tr::length(_S))); }        size_type find(_E _C, size_type _P = 0) const                {return (find((const _E *)&_C, _P, 1)); }        size_type rfind(const _Myt& _X, size_type _P = npos) const                {return (rfind(_X.c_str(), _P, _X.size())); }        size_type rfind(const _E *_S, size_type _P,                size_type _N) const                {if (_N == 0)                        return (_P < _Len ? _P : _Len);                if (_N <= _Len)                        for (const _E *_U = _Ptr +                                + (_P < _Len - _N ? _P : _Len - _N); ; --_U)                                if (_Tr::eq(*_U, *_S)                                        && _Tr::compare(_U, _S, _N) == 0)                                        return (_U - _Ptr);                                else if (_U == _Ptr)                                        break;                return (npos); }        size_type rfind(const _E *_S, size_type _P = npos) const                {return (rfind(_S, _P, _Tr::length(_S))); }        size_type rfind(_E _C, size_type _P = npos) const                {return (rfind((const _E *)&_C, _P, 1)); }        size_type find_first_of(const _Myt& _X,                size_type _P = 0) const                {return (find_first_of(_X.c_str(), _P, _X.size())); }        size_type find_first_of(const _E *_S, size_type _P,                size_type _N) const                {if (0 < _N && _P < _Len)                        {const _E *const _V = _Ptr + _Len;                        for (const _E *_U = _Ptr + _P; _U < _V; ++_U)                                if (_Tr::find(_S, _N, *_U) != 0)                                        return (_U - _Ptr); }                return (npos); }        size_type find_first_of(const _E *_S, size_type _P = 0) const                {return (find_first_of(_S, _P, _Tr::length(_S))); }        size_type find_first_of(_E _C, size_type _P = 0) const                {return (find((const _E *)&_C, _P, 1)); }        size_type find_last_of(const _Myt& _X,                size_type _P = npos) const                {return (find_last_of(_X.c_str(), _P, _X.size())); }        size_type find_last_of(const _E *_S, size_type _P,                size_type _N) const                {if (0 < _N && 0 < _Len)                        for (const _E *_U = _Ptr                                + (_P < _Len ? _P : _Len - 1); ; --_U)                                if (_Tr::find(_S, _N, *_U) != 0)                                        return (_U - _Ptr);                                else if (_U == _Ptr)                                        break;                return (npos); }        size_type find_last_of(const _E *_S,                size_type _P = npos) const                {return (find_last_of(_S, _P, _Tr::length(_S))); }        size_type find_last_of(_E _C, size_type _P = npos) const                {return (rfind((const _E *)&_C, _P, 1)); }        size_type find_first_not_of(const _Myt& _X,                size_type _P = 0) const                {return (find_first_not_of(_X.c_str(), _P,                        _X.size())); }        size_type find_first_not_of(const _E *_S, size_type _P,                size_type _N) const                {if (_P < _Len)                        {const _E *const _V = _Ptr + _Len;                        for (const _E *_U = _Ptr + _P; _U < _V; ++_U)                                if (_Tr::find(_S, _N, *_U) == 0)                                        return (_U - _Ptr); }                return (npos); }        size_type find_first_not_of(const _E *_S,                size_type _P = 0) const                {return (find_first_not_of(_S, _P, _Tr::length(_S))); }        size_type find_first_not_of(_E _C, size_type _P = 0) const                {return (find_first_not_of((const _E *)&_C, _P, 1)); }        size_type find_last_not_of(const _Myt& _X,                size_type _P = npos) const                {return (find_last_not_of(_X.c_str(), _P, _X.size())); }        size_type find_last_not_of(const _E *_S, size_type _P,                 size_type _N) const                {if (0 < _Len)                        for (const _E *_U = _Ptr                                + (_P < _Len ? _P : _Len - 1); ; --_U)                                if (_Tr::find(_S, _N, *_U) == 0)                                        return (_U - _Ptr);                                else if (_U == _Ptr)                                        break;                return (npos); }        size_type find_last_not_of(const _E *_S,                size_type _P = npos) const                {return (find_last_not_of(_S, _P, _Tr::length(_S))); }        size_type find_last_not_of(_E _C, size_type _P = npos) const                {return (find_last_not_of((const _E *)&_C, _P, 1)); }        _Myt substr(size_type _P = 0, size_type _M = npos) const                {return (_Myt(*this, _P, _M)); }        int compare(const _Myt& _X) const                {return (compare(0, _Len, _X.c_str(), _X.size())); }        int compare(size_type _P0, size_type _N0,                const _Myt& _X) const                {return (compare(_P0, _N0, _X, 0, npos)); }        int compare(size_type _P0, size_type _N0, const _Myt& _X,                size_type _P, size_type _M) const                {if (_X.size() < _P)                        _Xran();                if (_X._Len - _P < _M)                        _M = _X._Len - _P;                return (compare(_P0, _N0, _X.c_str() + _P, _M)); }        int compare(const _E *_S) const                {return (compare(0, _Len, _S, _Tr::length(_S))); }        int compare(size_type _P0, size_type _N0, const _E *_S) const                {return (compare(_P0, _N0, _S, _Tr::length(_S))); }        int compare(size_type _P0, size_type _N0, const _E *_S,                size_type _M) const                {if (_Len < _P0)                        _Xran();                if (_Len - _P0 < _N0)                        _N0 = _Len - _P0;                size_type _Ans = _Tr::compare(_Psum(_Ptr, _P0), _S,                        _N0 < _M ? _N0 : _M);                return (_Ans != 0 ? _Ans : _N0 < _M ? -1                        : _N0 == _M ? 0 : +1); }        _A get_allocator() const                {return (allocator); }protected:        _A allocator;private:        enum {_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7};        void _Copy(size_type _N)                {size_type _Ns = _N | _MIN_SIZE;                if (max_size() < _Ns)                        _Ns = _N;                _E *_S;                _TRY_BEGIN                        _S = allocator.allocate(_Ns + 2, (void *)0);                _CATCH_ALL                        _Ns = _N;                        _S = allocator.allocate(_Ns + 2, (void *)0);                _CATCH_END                if (0 < _Len)                        _Tr::copy(_S + 1, _Ptr, _Len);                size_type _Olen = _Len;                _Tidy(true);                _Ptr = _S + 1;                _Refcnt(_Ptr) = 0;                _Res = _Ns;                _Eos(_Olen); }        void _Eos(size_type _N)                {_Tr::assign(_Ptr[_Len = _N], _E(0)); }        void _Freeze()                {if (_Ptr != 0                        && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)                        _Grow(_Len);                if (_Ptr != 0)                        _Refcnt(_Ptr) = _FROZEN; }        bool _Grow(size_type _N, bool _Trim = false)                {if (max_size() < _N)                        _Xlen();                if (_Trim)                        _Len = 0;                else if (_N < _Len)                        _Len = _N;                if (_Ptr != 0                        && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)                        if (_N == 0)                                {_Tidy(true);                                return (false); }                        else                                {_Copy(_N);                                return (true); }                if (_N == 0)                        {if (_Trim)                                _Tidy(true);                        else if (_Ptr != 0)                                _Eos(0);                        return (false); }                else                        {if (_Trim && (_MIN_SIZE < _Res || _Res < _N))                                {_Tidy(true);                                _Copy(_N); }                        else if (!_Trim && _Res < _N)                                _Copy(_N);                        return (true); }}        static const _E * __cdecl _Nullstr()                {static const _E _C = _E(0);                return (&_C); }        static size_type _Pdif(const_pointer _P2, const_pointer _P1)                {return (_P2 == 0 ? 0 : _P2 - _P1); }        static const_pointer _Psum(const_pointer _P, size_type _N)                {return (_P == 0 ? 0 : _P + _N); }        static pointer _Psum(pointer _P, size_type _N)                {return (_P == 0 ? 0 : _P + _N); }        unsigned char& _Refcnt(const _E *_U)                {return (((unsigned char *)_U)[-1]); }        void _Tidy(bool _Built = false)                {if (!_Built || _Ptr == 0)                        ;                else if (_Refcnt(_Ptr) == 0 || _Refcnt(_Ptr) == _FROZEN)                        allocator.deallocate(_Ptr - 1, _Res + 2);                else                        --_Refcnt(_Ptr);                _Ptr = 0, _Len = 0, _Res = 0; }        _E *_Ptr;        size_type _Len, _Res;        };template<class _E, class _Tr, class _A>        const basic_string<_E, _Tr, _A>::size_type                basic_string<_E, _Tr, _A>::npos = -1;#ifdef  _DLL#pragma warning(disable:4231) /* the extern before template is a non-standard extension */extern template class _CRTIMP basic_string<char, char_traits<char>, allocator<char> >;extern template class _CRTIMP basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;#pragma warning(default:4231) /* restore previous warning */#endiftypedef basic_string<char, char_traits<char>, allocator<char> >        string;typedef basic_string<wchar_t, char_traits<wchar_t>,        allocator<wchar_t> > wstring;_STD_END#ifdef  _MSC_VER#pragma pack(pop)#endif  /* _MSC_VER */#endif /* _XSTRING *//* * Copyright (c) 1995-1998 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. */Fixes to <map>, <set>, and <xtree>The headers <map>, <set>, <xtree> (original 25 June 1998) presented here eliminate all need for thread locks and correct a number of thread-safety issuesfor template classes map, multimap, set, and multiset. They also solve some nasty problems with sharing these classes across DLLs. Note that no attempthas been made to retrofit the changes needed to make these template classes exception safe in the sense required by the final C++ Standard.// map standard header#ifndef _MAP_#define _MAP_/* This file is for use only in conjunction with a valid license forMicrosoft Visual C++ V5.0. Microsoft Corporation is in no way involvedwith the production or release of this file. The file is offered on an``as is'' basis.DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIESABOUT THE SUITABILITY OF THIS FILES, EITHER EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD.AND P.J. PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BYLICENSEE AS A RESULT OF USING THIS FILE.For additional information, contact Dinkumware, Ltd. (+1-888-4DINKUM orsupport@dinkumware.com).Version date: 25 June 1998 */#include <functional>#include <xtree>#ifdef  _MSC_VER#pragma pack(push,8)#endif  /* _MSC_VER */_STD_BEGIN                // TEMPLATE CLASS maptemplate<class _K, class _Ty, class _Pr = less<_K>,        class _A = allocator<_Ty> >        class map {public:        typedef map<_K, _Ty, _Pr, _A> _Myt;        typedef pair<const _K, _Ty> value_type;        struct _Kfn : public unary_function<value_type, _K> {                const _K& operator()(const value_type& _X) const                {return (_X.first); }                };        class value_compare                : public binary_function<value_type, value_type, bool> {                friend class map<_K, _Ty, _Pr, _A>;        public:                bool operator()(const value_type& _X,                        const value_type& _Y) const                        {return (comp(_X.first, _Y.first)); }        _PROTECTED:                value_compare(_Pr _Pred)                        : comp(_Pred) {}                _Pr comp;                };        typedef _K key_type;        typedef _Ty referent_type;        typedef _Pr key_compare;        typedef _A allocator_type;        typedef _A::reference _Tref;        typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;        typedef _Imp::size_type size_type;        typedef _Imp::difference_type difference_type;        typedef _Imp::reference reference;        typedef _Imp::const_reference const_reference;        typedef _Imp::iterator iterator;        typedef _Imp::const_iterator const_iterator;        typedef _Imp::reverse_iterator reverse_iterator;        typedef _Imp::const_reverse_iterator const_reverse_iterator;        typedef pair<iterator, bool> _Pairib;        typedef pair<iterator, iterator> _Pairii;        typedef pair<const_iterator, const_iterator> _Paircc;        explicit map(const _Pr& _Pred = _Pr(), const _A& _Al = _A())                : _Tr(_Pred, false, _Al) {}        typedef const value_type *_It;        map(_It _F, _It _L, const _Pr& _Pred = _Pr(),                const _A& _Al = _A())                : _Tr(_Pred, false, _Al)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator begin()                {return (_Tr.begin()); }        const_iterator begin() const                {return (_Tr.begin()); }        iterator end()                {return (_Tr.end()); }        const_iterator end() const                {return (_Tr.end()); }        reverse_iterator rbegin()                {return (_Tr.rbegin()); }        const_reverse_iterator rbegin() const                {return (_Tr.rbegin()); }        reverse_iterator rend()                {return (_Tr.rend()); }        const_reverse_iterator rend() const                {return (_Tr.rend()); }        size_type size() const                {return (_Tr.size()); }        size_type max_size() const                {return (_Tr.max_size()); }        bool empty() const                {return (_Tr.empty()); }        _A get_allocator() const                {return (_Tr.get_allocator()); }        _Tref operator[](const key_type& _Kv)                {iterator _P = insert(value_type(_Kv, _Ty())).first;                return ((*_P).second); }        _Pairib insert(const value_type& _X)                {_Imp::_Pairib _Ans = _Tr.insert(_X);                return (_Pairib(_Ans.first, _Ans.second)); }        iterator insert(iterator _P, const value_type& _X)                {return (_Tr.insert((_Imp::iterator&)_P, _X)); }        void insert(_It _F, _It _L)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator erase(iterator _P)                {return (_Tr.erase((_Imp::iterator&)_P)); }        iterator erase(iterator _F, iterator _L)                {return (_Tr.erase((_Imp::iterator&)_F,                        (_Imp::iterator&)_L)); }        size_type erase(const _K& _Kv)                {return (_Tr.erase(_Kv)); }        void clear()                {_Tr.clear(); }        void swap(_Myt& _X)                {std::swap(_Tr, _X._Tr); }        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }        key_compare key_comp() const                {return (_Tr.key_comp()); }        value_compare value_comp() const                {return (value_compare(_Tr.key_comp())); }        iterator find(const _K& _Kv)                {return (_Tr.find(_Kv)); }        const_iterator find(const _K& _Kv) const                {return (_Tr.find(_Kv)); }        size_type count(const _K& _Kv) const                {return (_Tr.count(_Kv)); }        iterator lower_bound(const _K& _Kv)                {return (_Tr.lower_bound(_Kv)); }        const_iterator lower_bound(const _K& _Kv) const                {return (_Tr.lower_bound(_Kv)); }        iterator upper_bound(const _K& _Kv)                {return (_Tr.upper_bound(_Kv)); }        const_iterator upper_bound(const _K& _Kv) const                {return (_Tr.upper_bound(_Kv)); }        _Pairii equal_range(const _K& _Kv)                {return (_Tr.equal_range(_Kv)); }        _Paircc equal_range(const _K& _Kv) const                {return (_Tr.equal_range(_Kv)); }protected:        _Imp _Tr;        };                // map TEMPLATE OPERATORStemplate<class _K, class _Ty, class _Pr, class _A> inline        bool operator==(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator!=(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (!(_X == _Y)); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator<(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator>(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (_Y < _X); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator<=(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (!(_Y < _X)); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator>=(const map<_K, _Ty, _Pr, _A>& _X,                const map<_K, _Ty, _Pr, _A>& _Y)        {return (!(_X < _Y)); }                // TEMPLATE CLASS multimaptemplate<class _K, class _Ty, class _Pr = less<_K>,        class _A = allocator<_Ty> >        class multimap {public:        typedef multimap<_K, _Ty, _Pr, _A> _Myt;        typedef pair<const _K, _Ty> value_type;        struct _Kfn : public unary_function<value_type, _K> {                const _K& operator()(const value_type& _X) const                {return (_X.first); }                };        class value_compare                : public binary_function<value_type, value_type, bool> {                friend class map<_K, _Ty, _Pr, _A>;        public:                bool operator()(const value_type& _X,                        const value_type& _Y) const                        {return (comp(_X.first, _Y.first)); }        _PROTECTED:                value_compare(_Pr _Pred)                        : comp(_Pred) {}                _Pr comp;                };        typedef _K key_type;        typedef _Ty referent_type;        typedef _Pr key_compare;        typedef _A allocator_type;        typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;        typedef _Imp::size_type size_type;        typedef _Imp::difference_type difference_type;        typedef _Imp::reference reference;        typedef _Imp::const_reference const_reference;        typedef _Imp::iterator iterator;        typedef _Imp::const_iterator const_iterator;        typedef _Imp::reverse_iterator reverse_iterator;        typedef _Imp::const_reverse_iterator const_reverse_iterator;        typedef pair<iterator, iterator> _Pairii;        typedef pair<const_iterator, const_iterator> _Paircc;        explicit multimap(const _Pr& _Pred = _Pr(),                const _A& _Al = _A())                : _Tr(_Pred, true, _Al) {}        typedef const value_type *_It;        multimap(_It _F, _It _L, const _Pr& _Pred = _Pr(),                        const _A& _Al = _A())                : _Tr(_Pred, true, _Al)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator begin()                {return (_Tr.begin()); }        const_iterator begin() const                {return (_Tr.begin()); }        iterator end()                {return (_Tr.end()); }        const_iterator end() const                {return (_Tr.end()); }        reverse_iterator rbegin()                {return (_Tr.rbegin()); }        const_reverse_iterator rbegin() const                {return (_Tr.rbegin()); }        reverse_iterator rend()                {return (_Tr.rend()); }        const_reverse_iterator rend() const                {return (_Tr.rend()); }        size_type size() const                {return (_Tr.size()); }        size_type max_size() const                {return (_Tr.max_size()); }        bool empty() const                {return (_Tr.empty()); }        _A get_allocator() const                {return (_Tr.get_allocator()); }        iterator insert(const value_type& _X)                {return (_Tr.insert(_X).first); }        iterator insert(iterator _P, const value_type& _X)                {return (_Tr.insert((_Imp::iterator&)_P, _X)); }        void insert(_It _F, _It _L)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator erase(iterator _P)                {return (_Tr.erase((_Imp::iterator&)_P)); }        iterator erase(iterator _F, iterator _L)                {return (_Tr.erase((_Imp::iterator&)_F,                        (_Imp::iterator&)_L)); }        size_type erase(const _K& _Kv = _K())                {return (_Tr.erase(_Kv)); }        void clear()                {_Tr.clear(); }        void swap(_Myt& _X)                {std::swap(_Tr, _X._Tr); }        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }        key_compare key_comp() const                {return (_Tr.key_comp()); }        value_compare value_comp() const                {return (value_compare(_Tr.key_comp())); }        iterator find(const _K& _Kv)                {return (_Tr.find(_Kv)); }        const_iterator find(const _K& _Kv) const                {return (_Tr.find(_Kv)); }        size_type count(const _K& _Kv) const                {return (_Tr.count(_Kv)); }        iterator lower_bound(const _K& _Kv)                {return (_Tr.lower_bound(_Kv)); }        const_iterator lower_bound(const _K& _Kv) const                {return (_Tr.lower_bound(_Kv)); }        iterator upper_bound(const _K& _Kv)                {return (_Tr.upper_bound(_Kv)); }        const_iterator upper_bound(const _K& _Kv) const                {return (_Tr.upper_bound(_Kv)); }        _Pairii equal_range(const _K& _Kv)                {return (_Tr.equal_range(_Kv)); }        _Paircc equal_range(const _K& _Kv) const                {return (_Tr.equal_range(_Kv)); }protected:        _Imp _Tr;        };                // multimap TEMPLATE OPERATORStemplate<class _K, class _Ty, class _Pr, class _A> inline        bool operator==(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator!=(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (!(_X == _Y)); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator<(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator>(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (_Y < _X); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator<=(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (!(_Y < _X)); }template<class _K, class _Ty, class _Pr, class _A> inline        bool operator>=(const multimap<_K, _Ty, _Pr, _A>& _X,                const multimap<_K, _Ty, _Pr, _A>& _Y)        {return (!(_X < _Y)); }_STD_END#ifdef  _MSC_VER#pragma pack(pop)#endif  /* _MSC_VER */#endif /* _MAP_ *//* * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* * This file is derived from software bearing the following * restrictions: * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this * software and its documentation for any purpose is hereby * granted without fee, provided that the above copyright notice * appear in all copies and that both that copyright notice and * this permission notice appear in supporting documentation. * Hewlett-Packard Company makes no representations about the * suitability of this software for any purpose. It is provided * "as is" without express or implied warranty. */// set standard header#ifndef _SET_#define _SET_/* This file is for use only in conjunction with a valid license forMicrosoft Visual C++ V5.0. Microsoft Corporation is in no way involvedwith the production or release of this file. The file is offered on an``as is'' basis.DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIESABOUT THE SUITABILITY OF THIS FILES, EITHER EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD.AND P.J. PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BYLICENSEE AS A RESULT OF USING THIS FILE.For additional information, contact Dinkumware, Ltd. (+1-888-4DINKUM orsupport@dinkumware.com).Version date: 25 June 1998 */#include <functional>#include <xtree>#ifdef  _MSC_VER#pragma pack(push,8)#endif  /* _MSC_VER */_STD_BEGIN                // TEMPLATE CLASS settemplate<class _K, class _Pr = less<_K>,        class _A = allocator<_K> >        class set {public:        typedef set<_K, _Pr, _A> _Myt;        typedef _K value_type;        struct _Kfn : public unary_function<value_type, _K> {                const _K& operator()(const value_type& _X) const                {return (_X); }                };        typedef _Pr value_compare;        typedef _K key_type;        typedef _Pr key_compare;        typedef _A allocator_type;        typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;        typedef _Imp::size_type size_type;        typedef _Imp::difference_type difference_type;        typedef _Imp::const_reference reference;        typedef _Imp::const_reference const_reference;        typedef _Imp::const_iterator iterator;        typedef _Imp::const_iterator const_iterator;        typedef _Imp::const_reverse_iterator reverse_iterator;        typedef _Imp::const_reverse_iterator const_reverse_iterator;        typedef pair<iterator, bool> _Pairib;        typedef pair<const_iterator, const_iterator> _Paircc;        explicit set(const _Pr& _Pred = _Pr(), const _A& _Al = _A())                : _Tr(_Pred, false, _Al) {}        typedef const value_type *_It;        set(_It _F, _It _L, const _Pr& _Pred = _Pr(),                const _A& _Al = _A())                : _Tr(_Pred, false, _Al)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        const_iterator begin() const                {return (_Tr.begin()); }        const_iterator end() const                {return (_Tr.end()); }        const_reverse_iterator rbegin() const                {return (_Tr.rbegin()); }        const_reverse_iterator rend() const                {return (_Tr.rend()); }        size_type size() const                {return (_Tr.size()); }        size_type max_size() const                {return (_Tr.max_size()); }        bool empty() const                {return (_Tr.empty()); }        _A get_allocator() const                {return (_Tr.get_allocator()); }        _Pairib insert(const value_type& _X)                {_Imp::_Pairib _Ans = _Tr.insert(_X);                return (_Pairib(_Ans.first, _Ans.second)); }        iterator insert(iterator _P, const value_type& _X)                {return (_Tr.insert((_Imp::iterator&)_P, _X)); }        void insert(_It _F, _It _L)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator erase(iterator _P)                {return (_Tr.erase((_Imp::iterator&)_P)); }        iterator erase(iterator _F, iterator _L)                {return (_Tr.erase((_Imp::iterator&)_F,                        (_Imp::iterator&)_L)); }        size_type erase(const _K& _Kv)                {return (_Tr.erase(_Kv)); }        void clear()                {_Tr.clear(); }        void swap(_Myt& _X)                {std::swap(_Tr, _X._Tr); }        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }        key_compare key_comp() const                {return (_Tr.key_comp()); }        value_compare value_comp() const                {return (_Tr.key_comp()); }        const_iterator find(const _K& _Kv) const                {return (_Tr.find(_Kv)); }        size_type count(const _K& _Kv) const                {return (_Tr.count(_Kv)); }        const_iterator lower_bound(const _K& _Kv) const                {return (_Tr.lower_bound(_Kv)); }        const_iterator upper_bound(const _K& _Kv) const                {return (_Tr.upper_bound(_Kv)); }        _Paircc equal_range(const _K& _Kv) const                {return (_Tr.equal_range(_Kv)); }protected:        _Imp _Tr;        };                // set TEMPLATE OPERATORStemplate<class _K, class _Pr, class _A> inline        bool operator==(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _K, class _Pr, class _A> inline        bool operator!=(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (!(_X == _Y)); }template<class _K, class _Pr, class _A> inline        bool operator<(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _K, class _Pr, class _A> inline        bool operator>(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (_Y < _X); }template<class _K, class _Pr, class _A> inline        bool operator<=(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (!(_Y < _X)); }template<class _K, class _Pr, class _A> inline        bool operator>=(const set<_K, _Pr, _A>& _X,                const set<_K, _Pr, _A>& _Y)        {return (!(_X < _Y)); }                // TEMPLATE CLASS multisettemplate<class _K, class _Pr = less<_K>,        class _A = allocator<_K> >        class multiset {public:        typedef multiset<_K, _Pr, _A> _Myt;        typedef _K value_type;        struct _Kfn : public unary_function<value_type, _K> {                const _K& operator()(const value_type& _X) const                {return (_X); }                };        typedef _Pr value_compare;        typedef _K key_type;        typedef _Pr key_compare;        typedef _A allocator_type;        typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;        typedef _Imp::size_type size_type;        typedef _Imp::difference_type difference_type;        typedef _Imp::const_reference reference;        typedef _Imp::const_reference const_reference;        typedef _Imp::const_iterator iterator;        typedef _Imp::const_iterator const_iterator;        typedef _Imp::const_reverse_iterator reverse_iterator;        typedef _Imp::const_reverse_iterator const_reverse_iterator;        typedef pair<const_iterator, const_iterator> _Paircc;        explicit multiset(const _Pr& _Pred = _Pr(),                const _A& _Al = _A())                : _Tr(_Pred, true, _Al) {}        typedef const value_type *_It;        multiset(_It _F, _It _L, const _Pr& _Pred = _Pr(),                        const _A& _Al = _A())                : _Tr(_Pred, true, _Al)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        const_iterator begin() const                {return (_Tr.begin()); }        const_iterator end() const                {return (_Tr.end()); }        const_reverse_iterator rbegin() const                {return (_Tr.rbegin()); }        const_reverse_iterator rend() const                {return (_Tr.rend()); }        size_type size() const                {return (_Tr.size()); }        size_type max_size() const                {return (_Tr.max_size()); }        bool empty() const                {return (_Tr.empty()); }        _A get_allocator() const                {return (_Tr.get_allocator()); }        iterator insert(const value_type& _X)                {return (_Tr.insert(_X).first); }        iterator insert(iterator _P, const value_type& _X)                {return (_Tr.insert((_Imp::iterator&)_P, _X)); }        void insert(_It _F, _It _L)                {for (; _F != _L; ++_F)                        _Tr.insert(*_F); }        iterator erase(iterator _P)                {return (_Tr.erase((_Imp::iterator&)_P)); }        iterator erase(iterator _F, iterator _L)                {return (_Tr.erase((_Imp::iterator&)_F,                        (_Imp::iterator&)_L)); }        size_type erase(const _K& _Kv)                {return (_Tr.erase(_Kv)); }        void clear()                {_Tr.clear(); }        void swap(_Myt& _X)                {std::swap(_Tr, _X._Tr); }        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }        key_compare key_comp() const                {return (_Tr.key_comp()); }        value_compare value_comp() const                {return (_Tr.key_comp()); }        const_iterator find(const _K& _Kv) const                {return (_Tr.find(_Kv)); }        size_type count(const _K& _Kv) const                {return (_Tr.count(_Kv)); }        const_iterator lower_bound(const _K& _Kv) const                {return (_Tr.lower_bound(_Kv)); }        const_iterator upper_bound(const _K& _Kv) const                {return (_Tr.upper_bound(_Kv)); }        _Paircc equal_range(const _K& _Kv) const                {return (_Tr.equal_range(_Kv)); }protected:        _Imp _Tr;        };                // multiset TEMPLATE OPERATORStemplate<class _K, class _Pr, class _A> inline        bool operator==(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _K, class _Pr, class _A> inline        bool operator!=(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (!(_X == _Y)); }template<class _K, class _Pr, class _A> inline        bool operator<(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _K, class _Pr, class _A> inline        bool operator>(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (_Y < _X); }template<class _K, class _Pr, class _A> inline        bool operator<=(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (!(_Y < _X)); }template<class _K, class _Pr, class _A> inline        bool operator>=(const multiset<_K, _Pr, _A>& _X,                const multiset<_K, _Pr, _A>& _Y)        {return (!(_X < _Y)); }_STD_END#ifdef  _MSC_VER#pragma pack(pop)#endif  /* _MSC_VER */#endif /* _SET_ *//* * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* * This file is derived from software bearing the following * restrictions: * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this * software and its documentation for any purpose is hereby * granted without fee, provided that the above copyright notice * appear in all copies and that both that copyright notice and * this permission notice appear in supporting documentation. * Hewlett-Packard Company makes no representations about the * suitability of this software for any purpose. It is provided * "as is" without express or implied warranty. */// tree internal header#ifndef _TREE_#define _TREE_/* This file is for use only in conjunction with a valid license forMicrosoft Visual C++ V5.0. Microsoft Corporation is in no way involvedwith the production or release of this file. The file is offered on an``as is'' basis.DINKUMWARE, LTD. AND P.J. PLAUGER MAKE NO REPRESENTATIONS OR WARRANTIESABOUT THE SUITABILITY OF THIS FILES, EITHER EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. DINKUMWARE, LTD.AND P.J. PLAUGER SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BYLICENSEE AS A RESULT OF USING THIS FILE.For additional information, contact Dinkumware, Ltd. (+1-888-4DINKUM orsupport@dinkumware.com).Version date: 25 June 1998 */#include <cstddef>#include <iterator>#include <memory>#include <xutility>#ifdef  _MSC_VER#pragma pack(push,8)#endif  /* _MSC_VER */_STD_BEGIN                // TEMPLATE CLASS _Treetemplate<class _K, class _Ty, class _Kfn, class _Pr, class _A>        class _Tree {protected:        typedef _POINTER_X(void, _A) _Genptr;        enum {_Red, _Black};        struct _Node;        friend struct _Node;        struct _Node {                _Genptr _Left, _Parent, _Right;                _Ty _Value;                char _Color, _Isnil;                };        typedef _POINTER_X(_Node, _A) _Nodeptr;        typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;        typedef _REFERENCE_X(const _K, _A) _Keyref;        typedef _REFERENCE_X(char, _A) _Charref;        typedef _REFERENCE_X(_Ty, _A) _Vref;        static _Charref _Color(_Nodeptr _P)                {return ((_Charref)(*_P)._Color); }        static _Charref _Isnil(_Nodeptr _P)                {return ((_Charref)(*_P)._Isnil); }        static _Keyref _Key(_Nodeptr _P)                {return (_Kfn()(_Value(_P))); }        static _Nodepref _Left(_Nodeptr _P)                {return ((_Nodepref)(*_P)._Left); }        static _Nodepref _Parent(_Nodeptr _P)                {return ((_Nodepref)(*_P)._Parent); }        static _Nodepref _Right(_Nodeptr _P)                {return ((_Nodepref)(*_P)._Right); }        static _Vref _Value(_Nodeptr _P)                {return ((_Vref)(*_P)._Value); }public:        typedef _Tree<_K, _Ty, _Kfn, _Pr, _A> _Myt;        typedef _K key_type;        typedef _Ty value_type;        typedef _A::size_type size_type;        typedef _A::difference_type difference_type;        typedef _POINTER_X(_Ty, _A) _Tptr;        typedef _POINTER_X(const _Ty, _A) _Ctptr;        typedef _REFERENCE_X(_Ty, _A) reference;        typedef _REFERENCE_X(const _Ty, _A) const_reference;                // CLASS iterator        class iterator;        friend class iterator;        class iterator : public _Bidit<_Ty, difference_type> {        public:                iterator()                        {}                iterator(_Nodeptr _P)                        : _Ptr(_P) {}                reference operator*() const                        {return (_Value(_Ptr)); }                _Tptr operator->() const                        {return (&**this); }                iterator& operator++()                        {_Inc();                        return (*this); }                iterator operator++(int)                        {iterator _Tmp = *this;                        ++*this;                        return (_Tmp); }                iterator& operator--()                        {_Dec();                        return (*this); }                iterator operator--(int)                        {iterator _Tmp = *this;                        --*this;                        return (_Tmp); }                bool operator==(const iterator& _X) const                        {return (_Ptr == _X._Ptr); }                bool operator!=(const iterator& _X) const                        {return (!(*this == _X)); }                void _Dec()                        {if (_Color(_Ptr) == _Red                                && _Parent(_Parent(_Ptr)) == _Ptr)                                _Ptr = _Right(_Ptr);                        else if (!_Isnil(_Left(_Ptr)))                                _Ptr = _Max(_Left(_Ptr));                        else                                {_Nodeptr _P;                                while (_Ptr == _Left(_P = _Parent(_Ptr)))                                        _Ptr = _P;                                _Ptr = _P; }}                void _Inc()                        {if (!_Isnil(_Right(_Ptr)))                                _Ptr = _Min(_Right(_Ptr));                        else                                {_Nodeptr _P;                                while (_Ptr == _Right(_P = _Parent(_Ptr)))                                        _Ptr = _P;                                if (_Right(_Ptr) != _P)                                        _Ptr = _P; }}                _Nodeptr _Mynode() const                        {return (_Ptr); }        protected:                _Nodeptr _Ptr;                };                // CLASS const_iterator        class const_iterator;        friend class const_iterator;        class const_iterator : public iterator {        public:                const_iterator()                        {}                const_iterator(_Nodeptr _P)                        : iterator(_P) {}                const_iterator(const iterator& _X)                        : iterator(_X) {}                const_reference operator*() const                        {return (_Value(_Ptr)); }                _Ctptr operator->() const                        {return (&**this); }                const_iterator& operator++()                        {_Inc();                        return (*this); }                const_iterator operator++(int)                        {iterator _Tmp = *this;                        ++*this;                        return (_Tmp); }                const_iterator& operator--()                        {_Dec();                        return (*this); }                const_iterator operator--(int)                        {iterator _Tmp = *this;                        --*this;                        return (_Tmp); }                bool operator==(const const_iterator& _X) const                        {return (_Ptr == _X._Ptr); }                bool operator!=(const const_iterator& _X) const                        {return (!(*this == _X)); }                };        typedef reverse_bidirectional_iterator<iterator,                value_type, reference, _Tptr, difference_type>                        reverse_iterator;        typedef reverse_bidirectional_iterator<const_iterator,                value_type, const_reference, _Ctptr, difference_type>                        const_reverse_iterator;        typedef pair<iterator, bool> _Pairib;        typedef pair<iterator, iterator> _Pairii;        typedef pair<const_iterator, const_iterator> _Paircc;        explicit _Tree(const _Pr& _Parg, bool _Marg = true,                const _A& _Al = _A())                : allocator(_Al),                key_compare(_Parg), _Multi(_Marg)                {_Init(); }        _Tree(const _Ty *_F, const _Ty *_L,                const _Pr& _Parg, bool _Marg = true,                const _A& _Al = _A())                : allocator(_Al),                key_compare(_Parg), _Multi(_Marg)                {_Init();                insert(_F, _L); }        _Tree(const _Myt& _X)                : allocator(_X.allocator),                key_compare(_X.key_compare), _Multi(_X._Multi)                {_Init();                _Copy(_X); }        ~_Tree()                {erase(begin(), end());                _Freenode(_Head);                _Head = 0, _Size = 0;                _Freenode(_Nil);                _Nil = 0; }        _Myt& operator=(const _Myt& _X)                {if (this != &_X)                        {erase(begin(), end());                        key_compare = _X.key_compare;                        _Copy(_X); }                return (*this); }        iterator begin()                {return (iterator(_Lmost())); }        const_iterator begin() const                {return (const_iterator(_Lmost())); }        iterator end()                {return (iterator(_Head)); }        const_iterator end() const                {return (const_iterator(_Head)); }        reverse_iterator rbegin()                {return (reverse_iterator(end())); }        const_reverse_iterator rbegin() const                {return (const_reverse_iterator(end())); }        reverse_iterator rend()                {return (reverse_iterator(begin())); }        const_reverse_iterator rend() const                {return (const_reverse_iterator(begin())); }        size_type size() const                {return (_Size); }        size_type max_size() const                {return (allocator.max_size()); }        bool empty() const                {return (size() == 0); }        _A get_allocator() const                {return (allocator); }        _Pr key_comp() const                {return (key_compare); }        _Pairib insert(const value_type& _V)                {_Nodeptr _X = _Root();                _Nodeptr _Y = _Head;                bool _Ans = true;                while (_X != _Nil)                        {_Y = _X;                        _Ans = key_compare(_Kfn()(_V), _Key(_X));                        _X = _Ans ? _Left(_X) : _Right(_X); }                if (_Multi)                        return (_Pairib(_Insert(_X, _Y, _V), true));                iterator _P = iterator(_Y);                if (!_Ans)                        ;                else if (_P == begin())                        return (_Pairib(_Insert(_X, _Y, _V), true));                else                        --_P;                if (key_compare(_Key(_P._Mynode()), _Kfn()(_V)))                        return (_Pairib(_Insert(_X, _Y, _V), true));                return (_Pairib(_P, false)); }        iterator insert(iterator _P, const value_type& _V)                {if (size() == 0)                        ;                else if (_P == begin())                        {if (key_compare(_Kfn()(_V), _Key(_P._Mynode())))                                return (_Insert(_Head, _P._Mynode(), _V)); }                else if (_P == end())                        {if (key_compare(_Key(_Rmost()), _Kfn()(_V)))                                return (_Insert(_Nil, _Rmost(), _V)); }                else                        {iterator _Pb = _P;                        if (key_compare(_Key((--_Pb)._Mynode()), _Kfn()(_V))                                && key_compare(_Kfn()(_V), _Key(_P._Mynode())))                                if (_Right(_Pb._Mynode()) == _Nil)                                        return (_Insert(_Nil, _Pb._Mynode(), _V));                                else                                        return (_Insert(_Head, _P._Mynode(), _V)); }                return (insert(_V).first); }        void insert(iterator _F, iterator _L)                {for (; _F != _L; ++_F)                        insert(*_F); }        void insert(const value_type *_F, const value_type *_L)                {for (; _F != _L; ++_F)                        insert(*_F); }        iterator erase(iterator _P)                {_Nodeptr _X;                _Nodeptr _Y = (_P++)._Mynode();                _Nodeptr _Z = _Y;                if (_Left(_Y) == _Nil)                        _X = _Right(_Y);                else if (_Right(_Y) == _Nil)                        _X = _Left(_Y);                else                        _Y = _Min(_Right(_Y)), _X = _Right(_Y);                if (_Y != _Z)                        {_Parent(_Left(_Z)) = _Y;                        _Left(_Y) = _Left(_Z);                        if (_Y == _Right(_Z))                                _Parent(_X) = _Y;                        else                                {_Parent(_X) = _Parent(_Y);                                _Left(_Parent(_Y)) = _X;                                _Right(_Y) = _Right(_Z);                                _Parent(_Right(_Z)) = _Y; }                        if (_Root() == _Z)                                _Root() = _Y;                        else if (_Left(_Parent(_Z)) == _Z)                                _Left(_Parent(_Z)) = _Y;                        else                                _Right(_Parent(_Z)) = _Y;                        _Parent(_Y) = _Parent(_Z);                        std::swap(_Color(_Y), _Color(_Z));                        _Y = _Z; }                else                        {_Parent(_X) = _Parent(_Y);                        if (_Root() == _Z)                                _Root() = _X;                        else if (_Left(_Parent(_Z)) == _Z)                                _Left(_Parent(_Z)) = _X;                        else                                _Right(_Parent(_Z)) = _X;                        if (_Lmost() != _Z)                                ;                        else if (_Right(_Z) == _Nil)                                _Lmost() = _Parent(_Z);                        else                                _Lmost() = _Min(_X);                        if (_Rmost() != _Z)                                ;                        else if (_Left(_Z) == _Nil)                                _Rmost() = _Parent(_Z);                        else                                _Rmost() = _Max(_X); }                if (_Color(_Y) == _Black)                        {while (_X != _Root() && _Color(_X) == _Black)                                if (_X == _Left(_Parent(_X)))                                        {_Nodeptr _W = _Right(_Parent(_X));                                        if (_Color(_W) == _Red)                                                {_Color(_W) = _Black;                                                _Color(_Parent(_X)) = _Red;                                                _Lrotate(_Parent(_X));                                                _W = _Right(_Parent(_X)); }                                        if (_Color(_Left(_W)) == _Black                                                && _Color(_Right(_W)) == _Black)                                                {_Color(_W) = _Red;                                                _X = _Parent(_X); }                                        else                                                {if (_Color(_Right(_W)) == _Black)                                                        {_Color(_Left(_W)) = _Black;                                                        _Color(_W) = _Red;                                                        _Rrotate(_W);                                                        _W = _Right(_Parent(_X)); }                                                _Color(_W) = _Color(_Parent(_X));                                                _Color(_Parent(_X)) = _Black;                                                _Color(_Right(_W)) = _Black;                                                _Lrotate(_Parent(_X));                                                break; }}                                else                                        {_Nodeptr _W = _Left(_Parent(_X));                                        if (_Color(_W) == _Red)                                                {_Color(_W) = _Black;                                                _Color(_Parent(_X)) = _Red;                                                _Rrotate(_Parent(_X));                                                _W = _Left(_Parent(_X)); }                                        if (_Color(_Right(_W)) == _Black                                                && _Color(_Left(_W)) == _Black)                                                {_Color(_W) = _Red;                                                _X = _Parent(_X); }                                        else                                                {if (_Color(_Left(_W)) == _Black)                                                        {_Color(_Right(_W)) = _Black;                                                        _Color(_W) = _Red;                                                        _Lrotate(_W);                                                        _W = _Left(_Parent(_X)); }                                                _Color(_W) = _Color(_Parent(_X));                                                _Color(_Parent(_X)) = _Black;                                                _Color(_Left(_W)) = _Black;                                                _Rrotate(_Parent(_X));                                                break; }}                        _Color(_X) = _Black; }                _Destval(&_Value(_Y));                _Freenode(_Y);                --_Size;                return (_P); }        iterator erase(iterator _F, iterator _L)                {if (size() == 0 || _F != begin() || _L != end())                        {while (_F != _L)                                erase(_F++);                        return (_F); }                else                        {_Erase(_Root());                        _Root() = _Nil, _Size = 0;                        _Lmost() = _Head, _Rmost() = _Head;                        return (begin()); }}        size_type erase(const _K& _X)                {_Pairii _P = equal_range(_X);                size_type _N = 0;                _Distance(_P.first, _P.second, _N);                erase(_P.first, _P.second);                return (_N); }        void erase(const _K *_F, const _K *_L)                {for (; _F != _L; ++_F)                        erase(*_F); }        void clear()                {erase(begin(), end()); }        iterator find(const _K& _Kv)                {iterator _P = lower_bound(_Kv);                return (_P == end()                        || key_compare(_Kv, _Key(_P._Mynode()))                                ? end() : _P); }        const_iterator find(const _K& _Kv) const                {const_iterator _P = lower_bound(_Kv);                return (_P == end()                        || key_compare(_Kv, _Key(_P._Mynode()))                                ? end() : _P); }        size_type count(const _K& _Kv) const                {_Paircc _Ans = equal_range(_Kv);                size_type _N = 0;                _Distance(_Ans.first, _Ans.second, _N);                return (_N); }        iterator lower_bound(const _K& _Kv)                {return (iterator(_Lbound(_Kv))); }        const_iterator lower_bound(const _K& _Kv) const                {return (const_iterator(_Lbound(_Kv))); }        iterator upper_bound(const _K& _Kv)                {return (iterator(_Ubound(_Kv))); }        const_iterator upper_bound(const _K& _Kv) const                {return (iterator(_Ubound(_Kv))); }        _Pairii equal_range(const _K& _Kv)                {return (_Pairii(lower_bound(_Kv), upper_bound(_Kv))); }        _Paircc equal_range(const _K& _Kv) const                {return (_Paircc(lower_bound(_Kv), upper_bound(_Kv))); }        void swap(_Myt& _X)                {std::swap(key_compare, _X.key_compare);                if (allocator == _X.allocator)                        {std::swap(_Head, _X._Head);                        std::swap(_Nil, _X._Nil);                        std::swap(_Multi, _X._Multi);                        std::swap(_Size, _X._Size); }                else                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}        friend void swap(_Myt& _X, _Myt& _Y)                {_X.swap(_Y); }protected:        void _Copy(const _Myt& _X)                {_Root() = _Copy(_X._Root(), _Head);                _Size = _X.size();                if (_Root() != _Nil)                        {_Lmost() = _Min(_Root());                        _Rmost() = _Max(_Root()); }                else                        _Lmost() = _Head, _Rmost() = _Head; }        _Nodeptr _Copy(_Nodeptr _X, _Nodeptr _P)                {_Nodeptr _R = _Nil;                if (!_Isnil(_X))                        {_Nodeptr _Y = _Buynode(_P, _Color(_X));                        _Consval(&_Value(_Y), _Value(_X));                        _Left(_Y) = _Nil, _Right(_Y) = _Nil;                        if (_R == _Nil)                                _R = _Y;                        _Left(_Y) = _Copy(_Left(_X), _Y);                        _Right(_Y) = _Copy(_Right(_X), _Y); }                return (_R); }        void _Erase(_Nodeptr _X)                {for (_Nodeptr _Y = _X; _Y != _Nil; _X = _Y)                        {_Erase(_Right(_Y));                        _Y = _Left(_Y);                        _Destval(&_Value(_X));                        _Freenode(_X); }}        void _Init()                {_Nil = _Buynode(0, _Black);                _Isnil(_Nil) = true;                _Left(_Nil) = 0, _Right(_Nil) = 0;                _Head = _Buynode(_Nil, _Red);                _Lmost() = _Head, _Rmost() = _Head;                _Size = 0; }        iterator _Insert(_Nodeptr _X, _Nodeptr _Y, const _Ty& _V)                {_Nodeptr _Z = _Buynode(_Y, _Red);                _Left(_Z) = _Nil, _Right(_Z) = _Nil;                _Consval(&_Value(_Z), _V);                ++_Size;                if (_Y == _Head || _X != _Nil                        || key_compare(_Kfn()(_V), _Key(_Y)))                        {_Left(_Y) = _Z;                        if (_Y == _Head)                                {_Root() = _Z;                                _Rmost() = _Z; }                        else if (_Y == _Lmost())                                _Lmost() = _Z; }                else                        {_Right(_Y) = _Z;                        if (_Y == _Rmost())                                _Rmost() = _Z; }                for (_X = _Z; _X != _Root()                        && _Color(_Parent(_X)) == _Red; )                        if (_Parent(_X) == _Left(_Parent(_Parent(_X))))                                {_Y = _Right(_Parent(_Parent(_X)));                                if (_Color(_Y) == _Red)                                        {_Color(_Parent(_X)) = _Black;                                        _Color(_Y) = _Black;                                        _Color(_Parent(_Parent(_X))) = _Red;                                        _X = _Parent(_Parent(_X)); }                                else                                        {if (_X == _Right(_Parent(_X)))                                                {_X = _Parent(_X);                                                _Lrotate(_X); }                                        _Color(_Parent(_X)) = _Black;                                        _Color(_Parent(_Parent(_X))) = _Red;                                        _Rrotate(_Parent(_Parent(_X))); }}                        else                                {_Y = _Left(_Parent(_Parent(_X)));                                if (_Color(_Y) == _Red)                                        {_Color(_Parent(_X)) = _Black;                                        _Color(_Y) = _Black;                                        _Color(_Parent(_Parent(_X))) = _Red;                                        _X = _Parent(_Parent(_X)); }                                else                                        {if (_X == _Left(_Parent(_X)))                                                {_X = _Parent(_X);                                                _Rrotate(_X); }                                        _Color(_Parent(_X)) = _Black;                                        _Color(_Parent(_Parent(_X))) = _Red;                                        _Lrotate(_Parent(_Parent(_X))); }}                _Color(_Root()) = _Black;                return (iterator(_Z)); }        _Nodeptr _Lbound(const _K& _Kv) const                {_Nodeptr _X = _Root();                _Nodeptr _Y = _Head;                while (_X != _Nil)                        if (key_compare(_Key(_X), _Kv))                                _X = _Right(_X);                        else                                _Y = _X, _X = _Left(_X);                return (_Y); }        _Nodeptr& _Lmost()                {return (_Left(_Head)); }        _Nodeptr& _Lmost() const                {return (_Left(_Head)); }        void _Lrotate(_Nodeptr _X)                {_Nodeptr _Y = _Right(_X);                _Right(_X) = _Left(_Y);                if (_Left(_Y) != _Nil)                        _Parent(_Left(_Y)) = _X;                _Parent(_Y) = _Parent(_X);                if (_X == _Root())                        _Root() = _Y;                else if (_X == _Left(_Parent(_X)))                        _Left(_Parent(_X)) = _Y;                else                        _Right(_Parent(_X)) = _Y;                _Left(_Y) = _X;                _Parent(_X) = _Y; }        static _Nodeptr _Max(_Nodeptr _P)                {while (!_Isnil(_Right(_P)))                        _P = _Right(_P);                return (_P); }        static _Nodeptr _Min(_Nodeptr _P)                {while (!_Isnil(_Left(_P)))                        _P = _Left(_P);                return (_P); }        _Nodeptr& _Rmost()                {return (_Right(_Head)); }        _Nodeptr& _Rmost() const                {return (_Right(_Head)); }        _Nodeptr& _Root()                {return (_Parent(_Head)); }        _Nodeptr& _Root() const                {return (_Parent(_Head)); }        void _Rrotate(_Nodeptr _X)                {_Nodeptr _Y = _Left(_X);                _Left(_X) = _Right(_Y);                if (_Right(_Y) != _Nil)                        _Parent(_Right(_Y)) = _X;                _Parent(_Y) = _Parent(_X);                if (_X == _Root())                        _Root() = _Y;                else if (_X == _Right(_Parent(_X)))                        _Right(_Parent(_X)) = _Y;                else                        _Left(_Parent(_X)) = _Y;                _Right(_Y) = _X;                _Parent(_X) = _Y; }        _Nodeptr _Ubound(const _K& _Kv) const                {_Nodeptr _X = _Root();                _Nodeptr _Y = _Head;                while (_X != _Nil)                        if (key_compare(_Kv, _Key(_X)))                                _Y = _X, _X = _Left(_X);                        else                                _X = _Right(_X);                return (_Y); }        _Nodeptr _Buynode(_Nodeptr _Parg, char _Carg)                {_Nodeptr _S = (_Nodeptr)allocator._Charalloc(                        1 * sizeof (_Node));                _Parent(_S) = _Parg;                _Color(_S) = _Carg;                _Isnil(_S) = false;                return (_S); }        void _Consval(_Tptr _P, const _Ty& _V)                {_Construct(&*_P, _V); }        void _Destval(_Tptr _P)                {_Destroy(&*_P); }        void _Freenode(_Nodeptr _S)                {allocator.deallocate(_S, 1); }        _A allocator;        _Pr key_compare;        _Nodeptr _Head, _Nil;        bool _Multi;        size_type _Size;        };                // tree TEMPLATE OPERATORStemplate<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator==(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (_X.size() == _Y.size()                && equal(_X.begin(), _X.end(), _Y.begin())); }template<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator!=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (!(_X == _Y)); }template<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator<(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (lexicographical_compare(_X.begin(), _X.end(),                _Y.begin(), _Y.end())); }template<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator>(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (_Y < _X); }template<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator<=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (!(_Y < _X)); }template<class _K, class _Ty, class _Kfn,        class _Pr, class _A> inline        bool operator>=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)        {return (!(_X < _Y)); }_STD_END#ifdef  _MSC_VER#pragma pack(pop)#endif  /* _MSC_VER */#endif /* _TREE_ *//* * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* * This file is derived from software bearing the following * restrictions: * * Copyright (c) 1994 * Hewlett-Packard Company * * Permission to use, copy, modify, distribute and sell this * software and its documentation for any purpose is hereby * granted without fee, provided that the above copyright notice * appear in all copies and that both that copyright notice and * this permission notice appear in supporting documentation. * Hewlett-Packard Company makes no representations about the * suitability of this software for any purpose. It is provided * "as is" without express or implied warranty. */