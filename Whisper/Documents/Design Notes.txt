I'm going to try and record in this file rationales for design designs made in Whisper.
By doing this I hope to:

1) Think through the implications of a given design more thoroughly. 
2) Provide a record of design decisions so that I can refer to them later.
3) Provide some documentation for people who are curious about Whisper's design.


9/18/98 
I've been working on XString. The motivation for this is this I want Whisper to
fully support Unicode (although perhaps not yet). This seems like it would be
painful to add at a later date so my hope is that by using XString the task
will become substantially easier.

My first thought was to use std::wstring. This would give me the std::string interface
which everyone is very familiar with and it means I could leverage off the work of the 
library vendors. Unfortunately this doesn't work as well as I had hoped. In particular it 
means I wouldn't have a ctor taking a const char* and c_str() would return a Unicode string.
I don't consider this acceptable: XString should be as easy as possible to use with char*'s. 

So, what I've done is write a brand new string class that closely parallels the std::string
class. The principle differences are that all operations work with char or XChar pointers
and I've added a couple of methods for dealing with pascal strings (Mac).

There are also some interesting implementation details. The string class in CW Pro4 uses
a reference counted string class. This is nice because it makes copying strings very fast,
but it's bad because it complicates the code and it means different string objects can
share the same data so mutexes are required in a threaded environment. I went with an
altogether different approach. Rather than using a seperate ref counted object I store
small strings (<= 32 characters) in a local array. This means that operations on 
small strings are very fast since no heap management is needed, but copying large strings
will be slower. The assumption here, of course, is that the vast majority of strings will
be small.

There's one more advantage of XString over std::string. Because XString is not a template
the object files generated by the compiler are substantially smaller when XString is used.
(But this won't carry over to the app: the linker should strip out duplicate instantiations
of std::string).


11/2/98
I've spent the last few weeks working on application level classes like XMenu, XWindow, and
XApplication. This is a sticky subject because of the differences between window handling
on the Mac and on Windows. On the Mac there's one menubar and windows are segregated into
three layers: regular, floating, and modal. Things are much more complex on Windows. To
begin with windows can be placed inside top level windows. This is how Windows implements
widgets. Top level windows may or may not have menubars and can optionally float. Dialogs
are implemented using "owned" windows which are like top level windows except that they
can't be moved behind their owner. And then, of course, there's MDI which opens up a new
can of worms.

Currently I have an XWindow class that encapsulates the notion of a top level window. On
Windows XWindow has an XMenuBar. By default this is created by calling XApplication::
OnCreateDefaultMenuBar. When a non-floating XWindow is activated on Windows it calls
XMenuBar::SwitchInstance. This allows both sides to access the current menubar by calling
XMenuBar::Instance.

Dialogs and MDI are currently not supported. The notion of window layers is exposed on the
Mac side, but isn't part of the cross platform API. The closest cross platform equivalent 
to window layers is the window type which is used to initialize the window options to a 
default state (all of the options can be overriden if desired). Currently the window types
are: kDocumentWindow, kModalDialog, kAlert, kPlainModal, kShadowedModal, kFloatingWindow, 
kSideFloater. Some of these are identical on Windows, for example kSideFloater is 
equivalent to kFloatingWindow.

The other sticky point is how to handle widgets. There are three possible target OS's here:
Win32 which handles widgets using nested windows, Mac OS with the Appearance Manager (this
can be installed in Mac OS 7) which handles widgets using nestable controls, and Mac OS
without the Appearance Manager which has only a few widgets, doesn't support nesting, tabbing,
or much of anything.

Frameworks on the Mac side have traditionally been written using the notion of panes/views
which are framework objects used to divide up a window into different regions for drawing
and user input. The panes/frames would occasionally serve as a wrapper around an OS widget,
but would often consist of 100% framework code.

On Windows and on the Mac with the Appearance Manager it's possible to do things differently.
Instead of creating a framework only object called a pane we can leverage off the OS objects.
This is how MFC, for examples, works (MFC does have a CView object, but it's very different
from what I've been talking about: instead of being a general purpose view object it's
narrowly tailored for displaying the contents of a document object).

This essentially means moving large bits of code from the framework into the OS. There are
of course some advantages to doing this: the implementation of widgets supplied by the OS
would likely be simplified and we'd be working with the OS instead of at cross purposes to
it. On the other hand by keeping this code in the framework we have much more control of
event routing, drawing, and pane management which allows us to provide a very flexible view
system.

My first attempt at designing a view system looked very much like the classes used by the
Mac frameworks. However this turned out to be a poor fit for Windows and, to a lesser extent,
the Appearance Manager. So, what I've done is to rewrite the classes so that rely on the OS
much more. The major classes are XBaseWindow which is a wrapper around a top level window,
XWindow which is a window that can contain controls, XRootControl which is the top level
control attached to an XWindow, and a bunch of XControl subclasses one of which is XUserControl.
This closely parallels how the Appearance Manager works, but I think turned out to work
quite well on Windows as well.

The drawbacks to doing this are that it requires that the Appearance Manager be installed,
there's a certain loss of flexibility (eg things like mouse downs are routed straight to 
the control so that parent controls don't have a chance to intercept events), and the 
Appearance Manager has some annoying weaknesses (the worst of which is that I haven't
been able to find a way to hook into the drawing of child controls which means that the
control hierachy will be drawn twice if a child has a draw extension).


11/14/98
Both the Appearance Manager and Windows have the notion of an input focus which serves as
the control/window that receives keyboard input. On Windows any window capable of user
input can be the focus (so a checkbox, for example, can have the focus). This isn't currently
true with the Appearance Manager, but Apple has indicated that they would like to do something
similar in the future.

In Whisper I've extended the concept of the input focus by creating a chain of command that
starts at the focus and works upwards to the application object. XApplication, XBaseWindow,
and XControl all inherit from XInputTargetMixin. When a keystroke or menu command is sent
to the focus and not handled the next target in the chain is given a chance to handle the
event.

This works fairly well, but is again, not as flexible as the older Mac frameworks. The first
drawback is that Windows does not provide a way for a window to refuse to relinquish the
focus. This means that users will be able to tab out of text boxes with invalid contents.
The second problem is that XInputTargetMixin does not have any hooks for letting the object
know when it has gained or lost the focus. This is easy to do on Windows, but dicier on the
Mac.


11/16/98
I've been thinking about how XControl should handle help. On the Mac there are two sorts of
help: balloon help which displays a short blurb about whatever is under the mouse and Apple
Guide which offers in depth help using an external application. Balloon help is toggled on
and off using the system menu Help. Apple Guide is launched through the Help menu or via
a context menu. On Windows help is implemented using an external application called WinHelp.
However you can achieve an effect similar to balloon help by using popup WinHelp windows
(this is how the question mark buttons in dialogs work).

Now this isn't too much of a problem: it's fairly easy to support all the different options.
However it's rather annoying that on Windows a full fledged hlp file has to be compiled just
to add contextual help to a few widgets. I've considered faking contextual help on Windows
by using the balloon help text and popping up a window that looks like a WinHelp popup
window. This would allow the balloon help text to be used on both platforms, would be more
helpful to users (eg balloon help has a seperate message for disabled controls which seems
unusual for WinHelp text), and easier to deal with since a hlp file doesn't have to be
compiled.

However I'm not at all sure it's wise to bypass WinHelp this way (and using WinHelp directly
with dynamic content looks non trivial). So, for now the two help system will be entirely
seperate.


11/18/98
Many application frameworks make use of the Decorator pattern by providing adorners which
can be attached to a UI object to change it's visual appearance. For example, Raven's
view editor used adorners to optionally draw a border around all the panes and to draw
resizing handles on the selected pane.

Raven implemented adorners using a generalized version of the Decorator pattern called the
Extension Object pattern (see Pattern Languages of Program Design 3). This worked very well
in Raven, but doesn't work quite as well in Whisper. The first problem is that the Appearance
Manager doesn't allow you to hook into the drawing of child controls. The best solution I
could come up with is to hide all the child controls before drawing a parent control.

The second problem is that Raven's draw extensions were clipped to the pane's parent. This 
was rather nice since it made it very easy to place frames or focus rings around a pane. 
However this is dicy to do on Windows because it requires drawing outside the control's 
window (I don't know if this is even possible) or drawing using the control's parent window. 
The later might be doable, but seems likely to cause problems (eg with determining dirty 
regions). Rather than deal with these complications I've elected to keep things simple by 
requiring that draw extensions draw only within their owner's extent.


11/29/98
The way that Windows handles keyboard messages is awfully annoying. There are at least four
cases: if a function key is pressed WM_KEYDOWN and WM_KEYUP messages are sent, if a "normal"
key is pressed WM_KEYDOWN, WM_CHAR, and WM_KEYUP are sent, if a diacritical character is typed
there will be seven messages including two WM_KEYDOWN's and one WM_CHAR, if an unrecognized
diacritical character is typed there will again be seven messages including two WM_KEYDOWN's 
and two WM_CHAR's. I was originally handling this by having OnKeyDown, OnChar, and OnKeyUp 
messages in XInputTargetMixin. This fits nicely with how Windows works and doesn't pose a 
problem on the Mac. However it seems very cumbersome to use.

For example, XDialogBox handles the return and escape keys. This means that XDialogBox
must override OnKeyDown to handle the keystroke and OnChar to eat the corresponding ASCII
character. This duplication really irks me, not least, because of the potential for weird
bugs if the two aren't synched up. To make matters worse it may not always be possible to
do this on the Mac (eg the clear and escape keys have the same ASCII code).

I think that it would be much better if OnKeyDown and OnChar were merged into a single
function. It seems like this is possible to do, but it's really slimy and is of questionable
robustness. So, for now I'm going to retain both OnKeyDown and OnChar.


12/7/98
I've been working on support for scrolling controls. I'm doing this with two different classes: 
XScrollerControl creates two scrollbars which it uses to scroll an XScrollableControl. This is
all fairly straight forward except when it comes time to draw the scrollable control and it's
child controls. Currently this is done by adjusting the draw context's origin immediately
before drawing the control. This works fine on the Mac, but doesn't work too well on Windows
because the OS doesn't realize when child controls have been scrolled into view.

This works on Macs because we subvert the normal drawing of child controls in order to do this
ourselves (we do this to ensure that draw extensions have a chance to draw). We could do
something similar on Windows, but it would be even dicier than the Mac because, unlike the
Mac, a child control can be drawn without going through the top level window.

Another option is to make the scrollable control the same size as the area we're scrolling
about in and reposition the control as we scroll. This would work, but there are complications:
the scrollable control may be inset a bit within the scroller (eg the scroller may have a
thin border). If this is the case the scrollable control will have to be clipped before it is
drawn.

A third option is to reposition child controls as the scrollable control scrolls. I'm sure
that this could be made to work, but I think the implementation would be quite ugly. For now,
I'm going to leave this alone: the scrollable control will draw correctly but child controls
will not.


1/23/99-1/28/99
I've been working on an XML parser class. I've been testing this with James Clark's extensive
test suite. As it turns out a few of the test files are Unicode (utf-16) and the accompanying
output files are utf-8 which means I need a utf-16 to utf-8 converter in order for my XML
output to match Clark's output file. So, I've decided to take the plunge and upgrade Whisper
to be fully Unicode savvy.

In order to do this six things must be done:

1) There needs to be some way to convert between utf-16 and other formats such as utf-8, Mac OS
Roman, Windows Latin1, ASCII, etc. This is doable on all supported platforms because Win95
supports the WideCharToMultiByte and MultiByteToWideChar functions and the Mac OS has the Text 
Encoding Converter which comes with Mac OS 8 and can be installed in Mac OS 7.1 (however the
utf-8 conversion requires TEC 1.2.1 or later (TEC 1.3 was included with Mac OS 8.1)).

2) There needs to be a Unicode savvy way to find the properties of a given character. C has
functions like isalpha and isdigit, but these won't work correctly for Unicode and don't cover
some of the important properties of Unicode characters. One problem with this is the handling
of combining characters (these are characters like diacriticals that modify the way the preceding
non-combining character is drawn). Section 5.4 of the Unicode standard says that combining
characters assume the property of the previous non-combining character.

Neither the Mac OS or Win95 provide Unicode savvy character property functions. NT includes a
rather inadequate set of functions that incorrectly handle combining characters. _The Unicode
Standard, Version 2.0_ includes a CD with datasets listing all these properties so I'm planning
to roll my own functions. The interface will probably look like IsDigit (XString, XChar).

3) Whisper includes StrToUpperStr and StrToLowerStr. These need to be rewritten to be Unicode
savvy (Unicode includes case mappings for Latin, Greek, Cyrillic, and Armenian). NT includes
two ways to case fold: CharLowerBuff/CharUpperBuff and LCMapString. CharLowerBuff/CharUpperBuff
folds according to the process locale. LCMapString allows the locale to be specified, but as far
as I can tell there's no such thing as a Unicode locale so these functions are inappropiate for
a general Unicode case folder (it's also amusing to note that CharUpperBuff doesn't behave
correctly even for Latin characters. For example U+00DF LATIN SMALL SHARP S (used in German)
becomes "SS" but CharUpperBuff can't handle this because it does an in place conversion). This,
again, is easy to deal with using the Unicode datasets so I'll implement it myself.

4) The Unicode standard includes a fairly complex set of guidelines for collating strings. 
Unfortunately these guidelines aren't enough to create a good general purpose collator since
the locale heavily influences how strings should be collated. This suggests that I should use
the OS facilities to compare strings since they do take advantage of locale information. 
Unfortunately only NT can compare Unicode strings. For the other OS's I'll have to convert the
string into a char* (using the string's XTextTranscoder object).

5) XString needs to be updated. In particular there needs to be a mechanism for converting
strings to and from Unicode and some thought must be given to how strings are compared. In doing
this I've been guided by the following goals:

a) Whisper string handling should be as simple to use as std::string for those with simple
needs.

b) String handling should be as efficient as possible. Note that this conflicts with goal
number 1: to be easy to use XString must accept char*'s, but these must be converted to
Unicode which is a bit slow. Fortunately you can usually get around this by prepending string
literals with an 'L'.

c) Advanced users should be supported. In particular it should be easy to convert to and from
Unicode and a variety of other character sets.

These goals suggest to me that the old XString interface should remain intact: in particular
there should still be an XString ctor accepting a const char* and there should be a c_str()
method that returns a char*. These methods should "do the right thing" wherever possible.
Those people with advanced needs should be able to easily override the default behavior.

The way I've done this is to add two XTextTranscoder objects to XString. One is the transcoder
used by the string and the other is a default transcoder that is used if the string transcoder
isn't specified. The default transcoder defaults to XMacRomanTranscoder on Macs and 
XWindowsLatin1Transcoder on Windows (note that these transcoders can be used on either platform).
The char* ctor now looks like this:
	XString(const char* str, uint32 length = npos, XTextTranscoder* takeTranscoder = nil);
If takeTranscoder is nil the default transcoder is used. Otherwise takeTranscoder is used wherever
the string object has to convert to and from a char*. There are also new methods for setting
the string transcoder and the default transcoder.

I've left XString::compare alone: it still does a bitwise comparison of the Unicode characters.
String collating can be divided into two major uses: those internal to the program and those
for the benefit of the user. The first case includes things like using a std::map with an
XString key. The second case includes things like displaying a list of font names to the user
in a menu or dialog.

The first case appears to be very common and should work fine with a bitwise comparison. The 
second case is, I think, rarer and includes a lot of variability in exactly how strings are
compared. This is the reason I've left XString::compare alone. For the second case I'll add
an abstract base class called XTextCollator and a concrete class called XSystemCollator.

6) Windows handles Unicode in a rather ugly manner: a build is Unicode if the UNICODE macro is
defined. If UNICODE is defined TCHAR and LPTSTR are defined as wchar_t and wchar_t*. If UNICODE
isn't defined they are a char and a char*. In order for string literals to work when UNICODE is
defined a TEXT macro is used that prepends the literal with an 'L' when UNICODE is defined. And,
lastly, Microsoft injects a huge number of macros into the global namespace by making every API
function with a string argument a macro. For example, CharUpperBuff is CharUpperBuffW if UNICODE 
is defined and CharUpperBuffA otherwise.

This is all rather annoying, but the worst part from my POV is that in order to support Unicode
on NT (and this is desirable, even if you don't care about Unicode, for performance reasons) you
need two completely seperate builds. However I don't think this scheme is neccesary with Whisper.
Rather than rely on the UNICODE macro I can simply call the wide API functions on NT and the
ASCII functions on Win95. 


4/1/99
I've been mulling over how controls should respond to clicks. Currently XValueControls
broadcast an SControlMessage when they're clicked. This works fairly well, but starts to
break down as additional controls need to handle clicks. For example, I'm working on a
listbox control and I want to let clients hook into double clicks (eg to treat a double
click in the list box as a click on an OK button in a dialog). If this is handled like
XValueControl it should broadcast, but this leads to a profusion of broadcaster and
listener types. This isn't horrible, but it's not very elegant either. I could change
things so that XControl did the broadcasting, but this is unpleasant since many controls
won't need this functionality (and some controls may want to broadcast extra info).

Instead of having listbox broadcast I tried using a mouse extension that called SimulateClick 
on a specified push button. This almost worked. The only problem is that double clicks inside
the scrollbar dismissed my dialog. This could be fixed by having XListBoxControl change a
double click to a single click before calling the mouse extensions, but this seemed rather
slimy.

Using a mouse extension didn't seem to be the correct approach, but the idea of adding an
extension to respond to clicks seemed sound enough. All that needs to be done is to execute
the extensions after the control has processed the click. This would allow the extension to
respond to either single or double clicks. (In the listbox I can convert double clicks to
single clicks after the control has processed the event. This isn't great, but IMO it's much
cleaner than doing it before mouse extensions or the control handles the event).

So, I've created an XClickExtension object that can be attached to any XControl to do
pretty much anything when the control is clicked. There are XClickExtension subclasses
that will send a MenuCommand to a specified input target, post an XCommand, and call a
function with zero, one, or two specified arguments (the function can be a member function
with the aid of Rich Hickey's callback template library).

This seems pretty sweet to me. It's more flexible and at least as easy to use as the old
approach. It will also work with any XControl, even those that usually don't respond to
clicks (eg an XPixMapControl). I'm planning on removing the XBroadcasterMixin from XValueControl
(although, at least for now, there will be a XValueControlClickExtension to simulate the
old behavior).


5/8/99
I've been working on support for document oriented apps. My first attempt relied on a base
class called XDocument and subclasses called XBinaryDocument and XXMLDocument. This would
have worked well for simple apps, but apps with multiple on-disk representations would, in
general, not be able to take advantage of the subclasses.

So, to better support more sophisticated apps I've changed XDocument so that it has a list
of XStorageObjects. Each XStorageObject has an extension/file type and callback objects
pointing to reader and writer functions. When the document needs to open or save it's data
it runs through the list of XStorageObjects until it finds a match and uses it to perform
the IO. Currently there are XStorageObject subclasses for binary streams and XML.

This seems to work quite well: it's very easy to support multiple disk formats (eg IconEdit
uses a binary stream or XML) and it should be easy to reuse new XStorageObject subclasses.


6/25/99
I'm currently working on streaming windows and controls in and out. This involves three major 
goals:

1) There needs to be a way to access the data format of a stream. This is important because
the layout editor can use this information when editing controls which makes it much easier
to add new controls to Whisper and provides a nice way to handle editing user controls. The
obvious way to handle this is to use XML and rely on the DTD. Unfortunately DTD's aren't
expressive enough (eg handling bitmasks is difficult). One of the XML schema proposals might
work, but none of them are standard yet and I'm reluctant to implement something that will
likely require major revisions down the road.

It's highly desirable that this meta-data be human readable and for efficiency reasons it
should be stored seperately from the data. XML should be able to do this just fine no matter
which format the data is stored in.

2) The data format should gracefully handle changes, especially the addition of new fields.
XML should be able to handle this rather well. Binary streams are more problematic. The way
I've handled this in the past is to embed version numbers in the stream. This works fairly
well but can quickly become cumbersome and requires people to be far-sighted enough to add
version numbers to each section of the stream that may change.

3) It should be possible to quickly stream in a fairly complex window on a low-end system.
This poses a bit of a problem for XML: parsing the text and creating the element tree is 
*much* slower than, for example, a binary stream. I'm not sure how much of a problem this
will be in practice, but there are ways to reduce this overhead (the simplest involve 
skipping the parsing step by storing the element tree using a binary stream).

Of course, a classic binary stream and an XML document are not our only choices. Other 
possibilities include a chunked binary format or some sort of optimized binary analogue
of XML. These are rather attractive since it seems possible to come up with a format as
flexible as XML, but much faster. OTOH they're not human readable, they're harder for
tools to process (eg spell checkers), and they're not standard.

Given all this I'm planning to use XML. This should work well except possibly for the
performance issues. However if there are problems it seems better to work on optimizing
XML rather than coming up with yet another storage format.


7/24/99
I've been pondering layout managers for a while. There are several problems that layout
managers seem capable of handling:

1) When something like an XRadioButton is streamed in LoadAppString is called to localize
the button's label. This will often result in a label that is significantly shorter or
longer than the original label. It seems to me that a layout manager can size each control
according to it's preferred size and shift the controls about to maintain the original
spacing. This seems like it would usually work pretty well, but there may be cases where
the results won't be as nice as human-localized dialog (especially when you consider right
to left languages). Because of this it's probably worthwhile to add code that checks for 
localized windows/dialogs.

2) The preferred control size is often slightly different on Mac and Windows. For example,
textboxes are supposed to be 18 or 16 pixels on Macs, but 20 pixels seems to work better
on Windows. This can be handled exactly like the localization case except that the size 
changes will be smaller so it's less likely that things will go awry.

3) The Mac OS 8 HIG has very detailed specifications for control sizing and spacing. The
Windows Interface Guidelines include similar info, but they don't address preferred sizes
and they're not nearly as picky about spacing. It'd be really nice if you could slap together
a rough dialog and let the code take care of tweaking everything so that it complies with the
HI guidelines.

It'd be sweet to have layout manager(s) to take care of all this automatically, especially
if they always did the right thing. Unfortunately this seems really tough to do: there are
all sorts of special cases that seem to complicate an already nasty problem. For example,
push buttons often look better when they're all the same size but you may want to allow the
sizes to vary if they're arranged horizontally. Another problem are right aligned static text
fields. These would either need special casing or a new layout manager that right aligns
child controls.

This all might be more or less doable by providing a bunch of different layout managers and 
using lot's of extra nestable controls, but I have strong doubts that writing all this
icky code is worthwhile. It seems to me that it might be better to scale back these ambitious
ideas and simply provide an easy way to load the window using the current platform/locale.
It'd be a bit of a pain to maintain seperate definitions of Mac and Win windows and localization
would be harder, but it's very straight-forward, doesn't require any fiddling with picking
out the right layout manager, and gives you full control over all the layout.


12/23/99
Instead of writing a specialized view editor I'm planning on writing a more or less generic 
XML editor that uses plugins to edit the different XML elements. This will make it easier to 
add new editors, it will make it possible to replace existing editors, and it provides a 
natural way to add app specific editors. This of course raises the question of the plugin 
architecture.

There are several posibilities. It'd be possible to simply use code fragments/DLLs, but these
don't support object oriented interfaces. On the Mac SOM can be used. However, as far as I know,
SOM isn't available on Windows and it appears to be going away on the Mac. The other obvious 
choice is COM. This would work fairly well on Windows and there are at least two existing Mac 
implementations (Microsoft's poorly supported one and Mozilla's XP-COM). However all error 
reporting in COM is done through return codes which IMO doesn't scale very well. Another problem 
is that COM relies on manual reference counting which is rather painful and often leads to hard 
to find leaks (smart pointer classes can help a lot with this, but they're not a solution unless 
they're used everywhere which they rarely are).

To work around these problems I've written my own COM-like framework. Unlike Microsoft's COM 
plugins are required to be written in C++. This is certainly a disadvantage, but it allows us 
to use exceptions instead of return codes, strings instead of GUID's, and automated reference
counting.
 
One unusual aspect of this system is that interfaces are individual objects that are aggregated
in a "boss" object. This is an idea that I borrowed from Adobe's InDesign. It seems a bit better
than the typical COM approach of multiply inheriting all interfaces into one mondo object and it
also allows for interesting techniques like plugins adding new interfaces to application bosses.
Bosses are defined in XML like this (these examples are from IconEdit):
	<Boss name = "Plugins Boss" singleton = "true">
		<Interface name = "IPlugins" impl = "IconEdit Plugins"/>
	</Boss>
	
Singleton bosses are created when the fragment they are in is loaded and deleted when their fragment 
is unloaded. Normal bosses are created when you use the boss name to query for an interface and 
deleted when the last interface pointer goes away. The only way to acquire an interface is to use 
one of the XInterfacePtr or XConstInterfacePtr ctors:
	explicit			XInterfacePtr(const ZBaseInterfacePtr& unknown);
	explicit			XInterfacePtr(const XString& boss);
The first constructor is used when you have an existing interface and want to check for a second
interface. The second is used when you want to instantiate a new boss (or acquire an interface on
a singleton boss). If the interface isn't found the interface pointer will be set to nil. Because
you can only acquire interfaces through XInterfacePtr or XConstInterfacePtr all reference counting
is automated. 

Interfaces are typically declared like this:
	class IPlugins : public XUnknown {
	
	public:
		virtual void 		Register(const XString& boss) = 0;
		virtual void 		UnRegister(const XString& boss) = 0;
	
		virtual uint32 		GetNumPlugins() const = 0;
		virtual const XString& GetBoss(uint32 index) const = 0;
	};
	
	typedef XInterfacePtr<IPlugins> IPluginsPtr;
	typedef XConstInterfacePtr<IPlugins> IConstPluginsPtr;
To avoid breaking old plugins you should make all the methods pure virtual and avoid adding new
methods to existing interfaces (you can instead add a new interface and query to see if it's there).

Before an interface can be used it needs to be registered with the object model:
	REGISTER_INTERFACE_NAME(IPlugins, "IPlugins");
	REGISTER_INTERFACE_FACTORY(CPlugins, L"IconEdit Plugins");
The first macro is needed so that XInterfacePtr can deduce the interface name from the class type.
The second macro is needed so that the object model can create the implementation objet given an
implementation name (from the boss resource). Note that the macro creates a prototype for the factory
so you don't need to include the CPlugins header (in fact implementation classes often don't have 
headers).

Interfaces are defined like this:
	class CPlugins : public IPlugins {	
	public:
		virtual				~CPlugins();
							CPlugins();
	
	public:
		virtual void 		Register(const XString& boss);
		virtual void 		UnRegister(const XString& boss);
	
		virtual uint32 		GetNumPlugins() const;
		virtual const XString& GetBoss(uint32 index) const;
	
	private:
		vector<XString>	mBosses;
	};
	
	DEFINE_INTERFACE_FACTORY(CPlugins)
	
	CPlugins::~CPlugins()
	{
	}
	
	CPlugins::CPlugins()
	{
	}
	
	void CPlugins::Register(const XString& boss)
	{
		ASSERT(find(mBosses.begin(), mBosses.end(), boss) == mBosses.end());
		ASSERT(boss.length() > 0);
		
		mBosses.push_back(boss);
	}

	// ...
The only tricky bit here is that you need to use DEFINE_INTERFACE_FACTORY to create a factory
function for the object model to use.

Once this is in place you can use the interface pointer classes to get your work done:
	IConstPluginsPtr plugins(L"Plugins Boss");			// IconEdit plugins register with the app's "Plugins Boss"
	IConstEffectPtr effect(plugins->GetBoss(index));	// now we have an interface on one of the plugin's bosses	
		
	status.name    = effect->GetName();					// so we can call a method that lives in a plugin
	status.enabled = true;


5/06/00
I've started rewriting the UI classes using Whisper's COM object model and I've run into a few snags.
For example, Whisper 1.0 had an XDeferredMenuCommand that would send a MenuCommand to an input target
when the command executed. Writing this using COM is a bit of a pain because there's no good way to
initialize the command since the only thing we can use is the ICommand interface. The standard answer
is to provide data interfaces. So, in this example, the command might have a data interface to get and
set the MenuCommand and another data interface to get and set the input target. This will work, but
it's clumsy and introduces non-obvious dependecies between commands and data interfaces.

So, what I've done instead is to introduce the notion of interface inheritance. XInterfacePtr has been
changed so that you can specify that you want the derived version of an interface. For example,
"XInterfacePtr<ICommand, IDeferredMenuCommand> command(boss);" will give you an IDeferredMenuCommand
pointer (or nil if the boss doesn't have a deferred menu command). Note that XInterfacePtr is the only
bit of code that has changed to support interface inheritance: the XML declarations, interface macros 
all work the same way and should all use the base class.

Note that this also makes versioning interfaces easier. For example, consider a large app that includes
plugins written by third parties. It's usually desirable to avoid breaking old plugins when releasing
a new version of the app, but this means that interfaces cannot be changed (eg if a method was added
new code might try to call it for a boss in an old plugin and all hell would break loose). The standard
answer is to tuck all the new methods away into a new interface, but this can leads to awkward
implementations. However interface inheritance takes care of these problems nicely. New code can test
to see if the new interface exists and new implementations don't have to write a second implementation
class.

5/26/00
After more thought and some disccussions with some of the guys at Adobe I've come to the conclusion
that interface inheritance is the wrong approach. The problem with interface inheritance is that the
XML file no longer specifies all the interfaces a boss supports and you cannot use helper classes (for
example, IDeferredMenuCommand descends from ICommand which means your implementation class cannot also
descend from XCommand.

So, what I've done is introduce the idea of interface aggregation. What this means is one implementation
in a boss can transparently implement multiple interfaces: client code uses the normal query mechanism
and the object model does a bit of extra work if the interface is aggregated with other interfaces.

The implementor controls the layout of interfaces using a variant of the normal XML boss element: 
	<Boss name = "C++ Plugin" singleton = "true">
		<Interface name = "ICountLines, ICountSemiColons" impl = "C++ Count Lines"/>
	</Boss>
Then in the implementation you merely mixin each of your interface classes. Note that you can inherit
from helper classes instead of interface classes. For example, if you're writing a command you'll
probably want to inherit from XCommand instead of ICommand.

8/19/00
All of Whisper's COM classes are reference counted and because all of the bookkeeping is done
automatically I had hoped that all the usual problems would be moot. However cyclic references have
turned out to be a real problem because it's often difficult to determine where the cycle is. I've
spent a few days experimenting with a mark and sweep garbage collector for bosses, but I couldn't
get it to work quite everywhere.

The idea behind the collector is that you want to mark all bosses referenced by singleton objects
and by XInterfacePtrs on the stack. The second is very easy, the first a bit more difficult. What
I did was change the code that constructed implementation classes so that it could identify
XInterfacePtr's that were embedded in the implementation class (as member data). With this in place
I had a garbage collector that worked great. But it didn't work for implementations of classes like
IMenu or IHierarchy that contained containers of XInterfacePtrs.

In order for this to work the collector must be told by client code that an implementation references
an interface. Giving the collector the XInterfacePtr is sticky because containers like std::vector
will copy it's elements occasionally. Giving the collector the XUnknown* solves that problem, but the
collector needs to then somehow figure out that some of the XInterfacePtrs aren't really on the stack.
I thrashed around for a few days, but was unable to come up with a workable solution.


Jesse Jones
jesjones@halcyon.com


